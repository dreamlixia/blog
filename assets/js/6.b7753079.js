(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{290:function(e,t,a){e.exports=a.p+"assets/img/Vue基本原理.93fa9ac1.jpg"},291:function(e,t,a){e.exports=a.p+"assets/img/数据双向绑定.bce02447.jpg"},292:function(e,t,a){e.exports=a.p+"assets/img/MVVM.e342748d.jpg"},356:function(e,t,a){"use strict";a.r(t);var s=a(14),v=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"深入响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入响应式原理"}},[e._v("#")]),e._v(" 深入响应式原理")]),e._v(" "),t("p",[e._v("待补充。。。")]),e._v(" "),t("h2",{attrs:{id:"_1-vue基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue基本原理"}},[e._v("#")]),e._v(" 1.Vue基本原理")]),e._v(" "),t("p",[e._v("当一个Vue实例创建时，Vue会遍历Data中的属性，用Object.defineProperty(Vue3.0使用Proxy)将它们转化为getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得已更新。\n")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{width:"100%",src:a(290),alt:""}})]),t("p"),e._v(" "),t("h2",{attrs:{id:"_2-双向数据绑定原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-双向数据绑定原理"}},[e._v("#")]),e._v(" 2.双向数据绑定原理")]),e._v(" "),t("p",[e._v("Vue.js是采用数据劫持结合发布-订阅模式的方式，通过Object.defineProperty()来劫持各个属性的getter，setter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：")]),e._v(" "),t("ol",[t("li",[e._v("需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化")]),e._v(" "),t("li",[e._v("compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),t("li",[e._v("Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")]),e._v(" "),t("li",[e._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n"),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{width:"100%",src:a(291),alt:""}})])])]),e._v(" "),t("h2",{attrs:{id:"_3-使用object-defineproperty-进行数据劫持的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用object-defineproperty-进行数据劫持的缺点"}},[e._v("#")]),e._v(" 3.使用Object.defineProperty()进行数据劫持的缺点")]),e._v(" "),t("p",[e._v("在对一些属性进行操作时，这种方式无法拦截，比如通过下标修改数组或者给对象新增属性，都不能触发组件的重新渲染，因为Object.defineProperty()不能拦截这些操作。更精确地说，对于数组而言，大部分操作时拦截不到的，只是Vue通过内部重写函数的方式解决了这个问题。")]),e._v(" "),t("p",[e._v("Vue3.0中已经不使用这个方法了，而是通过Proxy对对象进行代理，从而实现数据劫持。使用Proxy的好处是它可以监听到任何方式的数据改变，唯一的缺点就是兼容性问题，Proxy是ES6的语法。")]),e._v(" "),t("h2",{attrs:{id:"_4-mvvm、mvc、mvp的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvvm、mvc、mvp的区别"}},[e._v("#")]),e._v(" 4.MVVM、MVC、MVP的区别")]),e._v(" "),t("p",[e._v("MVVM、MVC、MVP是是三种常见的软件架构设计模式。主要通过分离关注点的方式来组织代码结构，优化开发效率。")]),e._v(" "),t("p",[t("strong",[e._v("背景：")]),e._v(" 在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。")]),e._v(" "),t("ol",[t("li",[e._v("MVC（Model View Controller）")])]),e._v(" "),t("p",[e._v("View和Model应用了观察者模式，当Model层发生改变的时候他会通知View层更新页面，而Controller是Mode层和View层的纽带，主要负责用户与应用的响应操作，当用户与页面产生交互时，Controller的事件触发器开始工作，调用Model层，来完成对Model层的修改，然后Model层再去通知View更新。")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("MVVM（Model View ViewModel）")])]),e._v(" "),t("ul",[t("li",[e._v("Model代表数据模型，数据和业务逻辑都在Model层中定义；")]),e._v(" "),t("li",[e._v("View代表UI视图，负责数据的展示；")]),e._v(" "),t("li",[e._v("ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；")])]),e._v(" "),t("p",[e._v("这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。\n")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{width:"100%",src:a(292),alt:""}})]),t("p"),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("MVP（Model View Presenter）")])]),e._v(" "),t("ul",[t("li",[e._v("各部分之间的通信，都是双向的；")]),e._v(" "),t("li",[e._v("View和Model不发生联系，都是通过Presenter传递。可以将一个presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常有用，因为视图的变化总是要比模型变化频繁；")]),e._v(" "),t("li",[e._v("View非常薄，不部署任何业务逻辑，被称为“被动视图”，既没有任何主动性。Presenter非常厚，业务逻辑都在那里。")])]),e._v(" "),t("blockquote",[t("p",[e._v("缺点：\n由于对视图的渲染都放在了presenter里，两者的交互就比较频繁。一旦视图需要变更，Presenter也需要变更。")])]),e._v(" "),t("h2",{attrs:{id:"_5-computed和watch的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-computed和watch的区别"}},[e._v("#")]),e._v(" 5.Computed和Watch的区别")]),e._v(" "),t("h4",{attrs:{id:"computed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[e._v("#")]),e._v(" Computed:")]),e._v(" "),t("ul",[t("li",[e._v("支持缓存，只有当依赖数据发生了变化，才会重新计算；")]),e._v(" "),t("li",[e._v("不支持异步，当Computed中有异步操作时，无法监听数据的变化；")]),e._v(" "),t("li",[e._v("Computed值默认走缓存，计算属性是基于他们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props数据进行计算的；")]),e._v(" "),t("li",[e._v("如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，一般会使用Computed；")]),e._v(" "),t("li",[e._v("如果属性值是函数，默认使用get方法，函数的返回值就是属性的属性值；在Computed中，有一个get和set方法，当数据发生变化时，会调用set方法；")])]),e._v(" "),t("h4",{attrs:{id:"watch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[e._v("#")]),e._v(" Watch：")]),e._v(" "),t("ul",[t("li",[e._v("不支持缓存，数据变化时，就触发相应操作；")]),e._v(" "),t("li",[e._v("支持异步监听；")]),e._v(" "),t("li",[e._v("监听的函数接收两个参数，最新的值和变化前的值；")]),e._v(" "),t("li",[e._v("监听的数据必须是data中声明的或者父组件props中带传递过来的，当发生变化时，会触发其他操作，函数有两个参数：\n"),t("ul",[t("li",[e._v("immediate: 组件加载立即触发回调函数；")]),e._v(" "),t("li",[e._v("deep: 深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。")])])])]),e._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结：")]),e._v(" "),t("ul",[t("li",[e._v("computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。")]),e._v(" "),t("li",[e._v("watch 侦听器 : 更多的是"),t("strong",[e._v("观察")]),e._v("的作用，"),t("strong",[e._v("无缓存性")]),e._v("，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。")])]),e._v(" "),t("p",[t("strong",[e._v("运用场景：")])]),e._v(" "),t("ul",[t("li",[e._v("当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。")]),e._v(" "),t("li",[e._v("当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])]),e._v(" "),t("h2",{attrs:{id:"_6-computed和methods区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-computed和methods区别"}},[e._v("#")]),e._v(" 6.Computed和Methods区别")]),e._v(" "),t("p",[e._v("相同点：")]),e._v(" "),t("p",[e._v("可以将同一函数定义为一个method或者一个计算属性，其最终的结果，两种方式是相同的。")]),e._v(" "),t("p",[e._v("不同点：")]),e._v(" "),t("ul",[t("li",[e._v("Computed：计算属性是基于它们的依赖进行缓存的，只有当相关依赖项发生改变时，才会去重新计算；")]),e._v(" "),t("li",[e._v("Method：在调用时总会执行该函数。")])]),e._v(" "),t("h2",{attrs:{id:"_7-slot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-slot"}},[e._v("#")]),e._v(" 7.slot")]),e._v(" "),t("h4",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),t("p",[e._v("插槽，Vue的内容分发机制。组件内部的模版引擎是使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这个标签元素是否显示，如何显示，是有父组件决定的。")]),e._v(" "),t("h4",{attrs:{id:"分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[e._v("#")]),e._v(" 分类")]),e._v(" "),t("ul",[t("li",[e._v("默认插槽：匿名插槽，slot没有指定name属性，一个组件只有一个默认插槽；")]),e._v(" "),t("li",[e._v("具名插槽：指定name属性的slot，一个组件可以有多个具名插槽；")]),e._v(" "),t("li",[e._v("作用域插槽：是匿名插槽和具名插槽的一个变体，不同点是子组件内部数据可以传递给父组件，父组件根据这个数据决定如何渲染该插槽；")])]),e._v(" "),t("h4",{attrs:{id:"实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[e._v("#")]),e._v(" 实现原理")]),e._v(" "),t("p",[e._v("当子组件vm实例化时，获取到父组件传入的slot标签内容，放在"),t("a",{attrs:{href:""}},[e._v("vm.$slot")]),e._v("中，默认插槽为"),t("a",{attrs:{href:""}},[e._v("vm.$slot.default")]),e._v("，具名插槽为"),t("a",{attrs:{href:""}},[e._v("vm.$slot.xxx")]),e._v("，当组件执行渲染函数时，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，如果存在数据，则可称为作用域插槽。")]),e._v(" "),t("h2",{attrs:{id:"_8-过滤器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-过滤器"}},[e._v("#")]),e._v(" 8.过滤器")]),e._v(" "),t("p",[e._v("过滤数据，Vue中使用filters来过滤数据，不会改变数据，只是过滤数据，改变用户看到的输出（Computed、Methods都是通过修改数据来处理数据的输出显示）。")]),e._v(" "),t("p",[t("strong",[e._v("使用场景：")])]),e._v(" "),t("ul",[t("li",[e._v("价格、时间等的格式化显示；")]),e._v(" "),t("li",[e._v("根据日期，显示比如多少天前之类的输出展示，可以使用filters过滤器来处理数据；")])]),e._v(" "),t("h4",{attrs:{id:"如何实现一个过滤器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现一个过滤器"}},[e._v("#")]),e._v(" 如何实现一个过滤器？")]),e._v(" "),t("p",[e._v("过滤器是一个函数，用在插值表达式{{}}和v-bind表达式中。然后放在操作符“｜”后面进行指示。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div>价格：{{price | filterPrice}}</div>\n\nfilters: {\n    filterPrice (price) {\n        return price ? '¥' + price : '---'\n    }\n}\n")])])]),t("h2",{attrs:{id:"_9-如何保存页面当前的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何保存页面当前的状态"}},[e._v("#")]),e._v(" 9.如何保存页面当前的状态")]),e._v(" "),t("p",[e._v("两种情况：组件会被卸载或不会被卸载")]),e._v(" "),t("h4",{attrs:{id:"组件会被卸载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件会被卸载"}},[e._v("#")]),e._v(" 组件会被卸载：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("使用LocalStorage / SessionStorage")]),e._v(" "),t("p",[e._v("在组件即将销毁的生命周期（componentWillUnmount / beforeDestroy）使用此方法，需要注意的是组件更新状态的时机。")]),e._v(" "),t("p",[t("strong",[e._v("优点：")])]),e._v(" "),t("ul",[t("li",[e._v("兼容性好，不需要引入第三方库或者工具；")]),e._v(" "),t("li",[e._v("简单快捷，可以满足大部分需求；")])]),e._v(" "),t("p",[t("strong",[e._v("缺点：")])]),e._v(" "),t("ul",[t("li",[e._v("状态通过JSON存储（相当于深拷贝），如果状态中有特殊情况（Date对象/Regexp对象）会得到字符串而不是原来的值；")]),e._v(" "),t("li",[e._v("使用标示flag时，执行后退、下一页等操作会失效；")])])]),e._v(" "),t("li",[t("p",[e._v("路由传参")]),e._v(" "),t("p",[e._v("使用react-router的link，prop -- to 实现路由传递参数，通过history.location.state获取")]),e._v(" "),t("p",[t("strong",[e._v("优点：")])]),e._v(" "),t("ul",[t("li",[e._v("简单快捷，不会污染LocalStorage/SessionStorage;")]),e._v(" "),t("li",[e._v("可以存储Date对象和Regexp对象；（不用担心JSON.stringify()和parse()的不足）")])]),e._v(" "),t("p",[t("strong",[e._v("缺点：")])]),e._v(" "),t("ul",[t("li",[e._v("如果跳转页面过多，每个页面都需要使用同样的方法进行传值取值，相当冗余混乱；")])])])]),e._v(" "),t("h4",{attrs:{id:"组件不会被卸载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件不会被卸载"}},[e._v("#")]),e._v(" 组件不会被卸载：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("单页面页面渲染")]),e._v(" "),t("p",[e._v("父子组件正常传参（prop）的方式")]),e._v(" "),t("p",[t("strong",[e._v("优点：")])]),e._v(" "),t("ul",[t("li",[e._v("代码量少，方便")])]),e._v(" "),t("p",[t("strong",[e._v("缺点：")])]),e._v(" "),t("ul",[t("li",[e._v("无法用路由定位页面")])])]),e._v(" "),t("li",[t("p",[e._v("keep-alive")]),e._v(" "),t("p",[e._v("<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。是一个抽象组件，它自身不会渲染一个组件，也不会出现在组件的父组件链中。")]),e._v(" "),t("p",[e._v("主要用于保存组件状态或避免重新渲染。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<keep-alive>\n    <component :is="view"></component>\n</keep-alive>\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<keep-alive>\n    <component v-if=\"$router.meta.keepAlive\"></component>\n</keep-alive>\n\n// router.js\n{\n    path: '/',\n    name: '',\n    component: () => import('./../src/XXX.vue'),\n    meta: {\n        keepAlive: true // 需要被缓存\n    }\n}\n")])])])])]),e._v(" "),t("h2",{attrs:{id:"_10-常见的事件修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-常见的事件修饰符"}},[e._v("#")]),e._v(" 10.常见的事件修饰符")]),e._v(" "),t("ul",[t("li",[e._v(".stop: 阻止事件冒泡")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:click.stop="doThis"></div>\n')])])]),t("ul",[t("li",[e._v(".prevent: 阻止默认行为")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 提交事件不再重载页面\n<form v-on:submit.prevent="doSubmit"></form>\n// 只有修饰符\n<form v-on:submit.prevent></form>\n')])])]),t("p",[e._v("修饰符可以串联：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:click.stop.prevent="doThat"></div>\n')])])]),t("ul",[t("li",[e._v(".capture: 与事件冒泡相反，事件捕获由外到内；")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:click.capture="doThis"></div>\n')])])]),t("ul",[t("li",[e._v(".self: 只会触发自己范围内的事件，不包含子元素；")])]),e._v(" "),t("p",[e._v("阻止所有点击：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:click.prevent.self="doThis"></div>\n')])])]),t("p",[e._v("只阻止元素对自身的点击")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:click.self.prevent="doThis"></div>\n')])])]),t("ul",[t("li",[e._v(".once: 只触发一次，还能被用到自定义的组件事件上。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:click.once="doThis"></div>\n')])])]),t("ul",[t("li",[e._v(".passive: 滚动事件的默认行为将会立即触发，不会等待onScroll完成，这其中包含 "),t("code",[e._v("event.preventDefault()")]),e._v(" 的情况")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-on:scroll.passive="onScroll"></div>\n')])])]),t("h2",{attrs:{id:"_11-v-if、v-show、v-html原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-v-if、v-show、v-html原理"}},[e._v("#")]),e._v(" 11.v-if、v-show、v-html原理")]),e._v(" "),t("h4",{attrs:{id:"v-html"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-html"}},[e._v("#")]),e._v(" v-html")]),e._v(" "),t("p",[e._v("更新元素的innerHTML。按普通HTML插入，不会进行Vue模板编译。")]),e._v(" "),t("blockquote",[t("p",[e._v("1、coped样式不会应中在v-html内部, 因为那部分HTML不会进行Vue模板编译；")]),e._v(" "),t("p",[e._v("2、在网上站动态渲染HTML是非常危险的，容易导致XSS攻击。只在可信内容上使用v-html，永不用在提交内容上。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div v-html="html"></div>\n')])])]),t("h4",{attrs:{id:"v-show"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-show"}},[e._v("#")]),e._v(" v-show")]),e._v(" "),t("p",[e._v("条件渲染，display: none，会生成vnode，render的时候会渲染真实节点，只是在render的过程中会修改属性display")]),e._v(" "),t("h4",{attrs:{id:"v-if"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-if"}},[e._v("#")]),e._v(" v-if")]),e._v(" "),t("p",[e._v("根据表达式值的truthiness来有条件渲染元素。在切换元素及它他的数据绑定/组件被销毁或重建。")]),e._v(" "),t("blockquote",[t("p",[e._v("当v-if和v-for一起使用，v-for的优先级高。")])]),e._v(" "),t("h4",{attrs:{id:"v-if和v-show的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show的区别"}},[e._v("#")]),e._v(" v-if和v-show的区别")]),e._v(" "),t("ol",[t("li",[e._v("v-if是dom操作，添加或删除dom元素，有局部编译/卸载的过程，v-show是改变css的display；")]),e._v(" "),t("li",[e._v("v-if用于运行条件不经常改变的场景，v-show适用于频繁变化；")]),e._v(" "),t("li",[e._v("v-if是惰性的，第一次如果不为真不进行编译，只有当条件第一次为真时才开始局部编译，v-show在任何条件下都会被编译，然后被缓存，dom元素保留；")]),e._v(" "),t("li",[e._v("v-if有更高的切换消耗，v-show有更高的初始渲染消耗；")])]),e._v(" "),t("h2",{attrs:{id:"_12-v-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-v-model"}},[e._v("#")]),e._v(" 12.v-model")]),e._v(" "),t("p",[e._v("数据双向绑定，本质是语法糖，背后的操作有两个：")]),e._v(" "),t("ul",[t("li",[e._v("v-bind绑定value；")]),e._v(" "),t("li",[e._v("v-on给当前元素绑定不同的事件；")])]),e._v(" "),t("blockquote",[t("p",[e._v("text和textarea绑定input事件；")]),e._v(" "),t("p",[e._v("checkbox、radio和select绑定change事件；")])]),e._v(" "),t("h4",{attrs:{id:"修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[e._v("#")]),e._v(" 修饰符")]),e._v(" "),t("ol",[t("li",[e._v(".lazy : change时更新\nv-model在每次input事件触发后将输入框的值与数据进行绑定，加上.lazy后转为在change事件之后进行同步")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<input v-model.lazy="msg">\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v(".number : 输入值转为数值类型")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<input v-model.number="age" type="number">\n')])])]),t("p",[e._v("因为即使在type定义为number，HTML输入元素的值也会总会返回字符串。如果这个值无法被parseFloat()解析，则会返回原始的值。")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v(".trim : 自动过滤首尾空格")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<input v-model.trim="msg">\n')])])]),t("h4",{attrs:{id:"自定义组件的v-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义组件的v-model"}},[e._v("#")]),e._v(" 自定义组件的v-model")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.component('custom-checkbox', {\n    model: {\n        prop: 'checked',\n        event: 'change'\n    },\n    props: {\n        checked: Boolean\n    },\n    template: `\n        <input\n            type=\"checkbox\"\n            v-bind:checked=\"checked\"\n            v-on:change=\"$emit('change', $event.target.checked)\"\n        >\n    `\n})\n")])])]),t("h4",{attrs:{id:"sync修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sync修饰符"}},[e._v("#")]),e._v(" .sync修饰符")]),e._v(" "),t("p",[t("strong",[e._v("作用：")]),e._v(" 可以实现子组件与父组件的双向绑定，并且可以实现子组件同步修改父组件的值。")]),e._v(" "),t("p",[t("strong",[e._v("本质：")]),e._v("\n正常父传子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<son :a="a" :b="b"></son>\n')])])]),t("p",[e._v("加上.sync后父传子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<son :a.sync="a" :b.sync="b"></son>\n')])])]),t("p",[e._v("它等价于")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<son\n    :a="a"\n    :b="b"\n    @update:a="val => a = val"\n    @update:b="val => b = val"\n></son>\n')])])]),t("p",[e._v("相当于多了一个事件监听，事件名为update:a, 回调函数中，会把接收到的值赋给属性绑定的数据项中。")]),e._v(" "),t("h4",{attrs:{id:"sync与v-model的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sync与v-model的区别"}},[e._v("#")]),e._v(" .sync与v-model的区别")]),e._v(" "),t("p",[t("strong",[e._v("相同点：")]),e._v(" 都是语法糖")]),e._v(" "),t("p",[t("strong",[e._v("不同点：")])]),e._v(" "),t("ul",[t("li",[e._v("格式写法不同，都可以实现父子组件的数据双向通信。")])]),e._v(" "),t("blockquote",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('v-model="num"\n:num.sync="num"\n\nv-model: @input + value\n:num.sync: @update:num \n')])])])]),e._v(" "),t("ul",[t("li",[e._v("v-model只能有一个，.sync可以有多个")])]),e._v(" "),t("h2",{attrs:{id:"_13-为什么vue的data属性是一个函数而不是对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-为什么vue的data属性是一个函数而不是对象"}},[e._v("#")]),e._v(" 13.为什么Vue的data属性是一个函数而不是对象")]),e._v(" "),t("h4",{attrs:{id:"实例和组件定义的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例和组件定义的区别"}},[e._v("#")]),e._v(" 实例和组件定义的区别")]),e._v(" "),t("ul",[t("li",[e._v("实例定义既可以是对象，也可以是函数")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const app = new Vue({\n    el: \"#app\",\n    // 对象格式\n    data: {\n        foo: 'foo'\n    },\n    // 函数格式\n    data () {\n        return {\n            foo: 'foo'\n        }\n    }\n})\n")])])]),t("ul",[t("li",[e._v("组件定义只能是函数")])]),e._v(" "),t("p",[e._v("如果为组件的data直接定一个对象")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.component({\n    template: `<div>组件</div>`,\n    data: {\n        foo: 'foo'\n    }\n})\n")])])]),t("p",[e._v("会看到报错信息：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('[Vue warn]: The "data" option should be a function that returns a per-instance value in component defintions.\n')])])]),t("h4",{attrs:{id:"原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[e._v("#")]),e._v(" 原因：")]),e._v(" "),t("p",[e._v("根实例是单例，不会产生数据污染的情况。\n如果一个组件有多个Vue实例，就会造成多个组件实例对象共用一个data对象（共用一个内存地址，对象A的值发生改变，同样对象B的值也发生改变），产生数据污染，而使用函数，初始化data时，就会返回全新的data对象。")]),e._v(" "),t("h2",{attrs:{id:"_14-对keep-alive的理解-如何实现-具体缓存的是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-对keep-alive的理解-如何实现-具体缓存的是什么"}},[e._v("#")]),e._v(" 14.对keep-alive的理解，如何实现，具体缓存的是什么")]),e._v(" "),t("ol",[t("li",[e._v("概念\n如果需要在组件切换的时候，保留一些组件的状态防止多次渲染，就需要使用<keep-alive>包裹需要保存的组件。")])]),e._v(" "),t("p",[e._v("用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<keep-alive> // 基本\n    <component :is="view"></component>\n</keep-alive>\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<keep-alive> // 多个条件判断的子组件\n    <compo-a v-if="a > 1"></compo-a>\n    <compo-b v-else></compo-b>\n</keep-alive>\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Props")])]),e._v(" "),t("ul",[t("li",[e._v("includes: 只能缓存名称匹配的组件")]),e._v(" "),t("li",[e._v("exculdes: 任何名称匹配的组件都不会被缓存")]),e._v(" "),t("li",[e._v("max: 最多可以缓存组件实例的个数")])]),e._v(" "),t("p",[e._v("<keep-alive>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。")]),e._v(" "),t("p",[e._v("当组件在<keep-alive>内被切换时，生命周期 activated 和 deactivated 会被调用。")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("render函数")])]),e._v(" "),t("ul",[t("li",[e._v("会在<keep-alive>组件内部去写自己的内容，所以可以获取slot的内容，然后根据这个去获取组件")]),e._v(" "),t("li",[e._v("<keep-alive>只对第一个组件有效，所以只获取第一个子组件")]),e._v(" "),t("li",[e._v("和<keep-alive>搭配使用的一般有：动态组件和router-view")])]),e._v(" "),t("p",[e._v("内容待更新……")]),e._v(" "),t("h4",{attrs:{id:"lru-least-recently-used-缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru-least-recently-used-缓存策略"}},[e._v("#")]),e._v(" LRU （least recently used）缓存策略")]),e._v(" "),t("p",[e._v('LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。\nLRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 "如果数据最近被访问过，那么将来被访问的几率也更高"。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶')]),e._v(" "),t("ul",[t("li",[e._v("新数据插入到链表头部")]),e._v(" "),t("li",[e._v("每当缓存命中（即缓存数据被访问），则将数据移到链表头部")]),e._v(" "),t("li",[e._v("链表满的时候，将链表尾部的数据丢弃。")])]),e._v(" "),t("h2",{attrs:{id:"_15-nexttick的原理和作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-nexttick的原理和作用"}},[e._v("#")]),e._v(" 15.$nextTick的原理和作用")]),e._v(" "),t("ol",[t("li",[e._v("全局方法\n将回调推迟到下一个DOM更新周期后执行。在更改了一些数据等待DOM更新后立即使用它。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import { createApp, nextTick } from 'vue'\nconst App = createApp({\n    setUp () {\n        const message = ref('Hello')\n        const changeMessage = async newMessage => {\n            message.value = newMessage\n            await nextTick()\n            console.log('DOM updated')\n        }\n    }\n})\n\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("实例方法\n它跟全局方法 nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("createApp({\n    methods: {\n        doSomeThing() {\n            this.message = 'message'\n            // dom未更新\n            this.$nextTick(function(){\n                // dom更新了，this被绑定到当前实例\n                this.forExample()\n            })\n        }\n    }\n})\n")])])]),t("h2",{attrs:{id:"_16-keep-alive中的生命周期有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-keep-alive中的生命周期有哪些"}},[e._v("#")]),e._v(" 16.keep-alive中的生命周期有哪些？")]),e._v(" "),t("ul",[t("li",[e._v("activated：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。")]),e._v(" "),t("li",[e._v("deactivated：组件被停用（离开路由）时调用。")])]),e._v(" "),t("p",[e._v("keep-alive 是Vue提供的内置组件，对组件进行缓存，在组件切换过程中将状态保存在缓存中，防止重复渲染DOM。")]),e._v(" "),t("h2",{attrs:{id:"_17-组件通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-组件通信"}},[e._v("#")]),e._v(" 17.组件通信")]),e._v(" "),t("ol",[t("li",[e._v("父组件通过props向子组件传递数据，子组件通过$emit给父组件传递数据，父组件通过v-on监听并接收参数，兄弟组件用$emit发送，$on接收。")]),e._v(" "),t("li",[e._v("依赖注入：用于父子/祖孙之间的通信，provide发送数据或方法，inject接收数据或方法。")]),e._v(" "),t("li",[e._v("ref/$refs: 用于父子组件的通信，ref写在子组件上，他的引用指向了子组件的实例，可以通过实例来访问组件的数据和方法：")])]),e._v(" "),t("p",[e._v("子组件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export default {\n  data () {\n    return {\n      name: 'JavaScript'\n    }\n  },\n  methods: {\n    sayHello () {\n      console.log('hello')\n    }\n  }\n}\n")])])]),t("p",[e._v("父组件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n  <child ref=\"child\"></component-a>\n</template>\n<script>\n  import child from './child.vue'\n  export default {\n    components: { child },\n    mounted () {\n      console.log(this.$refs.child.name);  // JavaScript\n      this.$refs.child.sayHello();  // hello\n    }\n  }\n<\/script>\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[e._v("$parent和$children:\n"),t("ul",[t("li",[e._v("$parent: 可以访问父组件的实例，访问的是上一级父组件的属性和方法；")]),e._v(" "),t("li",[e._v("$children: 访问的是子组件的实例，但是不能保证顺序，并且访问的数据也不是响应式的。")])])]),e._v(" "),t("li",[e._v("跨代通信：$attrs和$listeners.")])]),e._v(" "),t("p",[e._v("inheritAttrs:")]),e._v(" "),t("ul",[t("li",[e._v("默认值为true，继承所有父组件除props之外的所有属性；")]),e._v(" "),t("li",[e._v("false，只继承父组件的class属性。")])]),e._v(" "),t("p",[e._v("$attrs: 继承所有父组件的属性（出prop传递的属性、class、style），一般用在子组件上；")]),e._v(" "),t("p",[e._v('$listeners: 属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合v-on="$listeners"将所有事件监听器指向这个组件的某个特定子元素，相当于子组件继承父组件的事件。')]),e._v(" "),t("h2",{attrs:{id:"_18-vue的性能优化有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-vue的性能优化有哪些"}},[e._v("#")]),e._v(" 18.Vue的性能优化有哪些")]),e._v(" "),t("ul",[t("li",[e._v("代码模块化、组件化、复用性高、可配置性强、减少重复代码")]),e._v(" "),t("li",[e._v("懒加载模块")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const getDemo = () => import('./demo.js');\ngetDemo().then({ testDemo } => testDemo());\n")])])]),t("ul",[t("li",[e._v("懒加载路由拆分")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const routes = [\n    {path: '/', component: () => import('./dashboard.vue')}, \n    {path: '/page', component: () => import('./page.vue')}\n]\n")])])]),t("ul",[t("li",[e._v("使用cdn加载外部资源或静态文件上cdn")]),e._v(" "),t("li",[e._v("减少图片使用，使用css3代替图片，优化压缩图片（base64、软件压缩、cdn压缩）")]),e._v(" "),t("li",[e._v("v-for进行遍历渲染的时候，每一项都设置唯一的key值")]),e._v(" "),t("li",[e._v("使用的全局变量在销毁时全部置为null，避免内存泄漏")]),e._v(" "),t("li",[e._v("使用keep-alive对组件进行缓存")]),e._v(" "),t("li",[e._v("打包优化，productionSourceMap设置为false，否则最终打包过后会生成一些map文件，如果不关掉，生成环境是可以通过map去查看源码，并且可以开启gzip压缩，使打包过后体积变小")])]),e._v(" "),t("h2",{attrs:{id:"如何修改element组件库的样式-样式穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何修改element组件库的样式-样式穿透"}},[e._v("#")]),e._v(" 如何修改element组件库的样式： 样式穿透")]),e._v(" "),t("p",[e._v("组件样式穿透 >>> 或 /deep/ 或 ::deep")]),e._v(" "),t("p",[e._v("css原生样式，可以直接使用 >>>")]),e._v(" "),t("p",[e._v("sass/less可能无法识别，使用 /deep/ 和 ::deep 选择器(都是 >>> 的别名)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<style scoped>\n     .a {\n        >>> .b {\n            color: red;\n        }\n     }\n</style>\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<style lang='sass' scoped>\n.a {\n    /deep/ .b {\n        color: blue;\n    }\n}\n// 或者\n.a /deep/ .b {\n    color: blue;\n}\n</style>\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<style lang='sass' scoped>\n.a {\n    ::deep .b {\n        color: blue;\n    }\n}\n// 或者\n.a ::deep .b {\n    color: blue;\n}\n</style>\n")])])]),t("p",[e._v("vue3.0的环境下，安装项目时选择了dart-sass。这个不支持/deep/和>>>写法。只能用::deep，选择node-sass不会有这个问题。")]),e._v(" "),t("p",[e._v("建议使用::deep方式，保险并且编译速度更快。")]),e._v(" "),t("h2",{attrs:{id:"proxy实现数据响应式-vue3-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proxy实现数据响应式-vue3-0"}},[e._v("#")]),e._v(" Proxy实现数据响应式 Vue3.0")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let onWatch = (obj, setBind, getLogger) => {\n    let handler = {\n        get(taget, property, receiver) {\n            getLogger(target, property)\n            return Reflect.get(target, property, receiver)\n        },\n        set(target, property, value, receiver) {\n            setBind(value, property)\n            return Reflect.set(target, property, value)\n        }\n    }\n    return new Proxy(obj, handler)\n}\nlet obj = { a: 1 }\nlet p = onWatch(\n    obj,\n    (v, property) => {\n        console.log(`监听到属性${property}改变为${v}`)\n    },\n    (target, property) => {\n        console.log(`'${property}' = ${target[property]}`)\n    }\n)\np.a = 2 // 监听到属性a改变\np.a // 'a' = 2\n")])])]),t("p",[e._v("当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式， 需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属 性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现 有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式 的数据改变，唯一缺陷就是浏览器的兼容性不好。")]),e._v(" "),t("hr"),e._v(" "),t("hr"),e._v(" "),t("comment-comment")],1)}),[],!1,null,null,null);t.default=v.exports}}]);