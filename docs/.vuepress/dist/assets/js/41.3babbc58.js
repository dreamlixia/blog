(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{459:function(e,n,t){"use strict";t.r(n);var s=t(27),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"基础版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础版本"}},[e._v("#")]),e._v(" 基础版本")]),e._v(" "),t("p",[e._v("设定三个状态 PENDING、FULFILLED、REJECTED, 只能由 PENDING 改为 FULFILLED、REJECTED, 并且只能改变一次")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(executor) {\n    this.state = PENDING;\n    this.value = null;\n    this.reason = null;\n\n    const resolve = (value) => {\n        if(this.state == PENDING) {\n            this.state = FULFILLED;\n            this.value = value;\n        }\n    }\n\n    const reject = (reason) => {\n        if(this.state == PENDING) {\n            this.state = REJECTED;\n            this.reason = reason;\n        }\n    }\n\n    try{\n        executor(resolve, reject);\n    } catch (reason) {\n        reject(reason);\n    }\n}\n")])])]),t("h2",{attrs:{id:"then方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then方法"}},[e._v("#")]),e._v(" then方法")]),e._v(" "),t("ul",[t("li",[e._v("then方法接受两个参数，onFulfilled、onRejected, 他们分别在 PENDING 改变为 FULFILLED 、REJECTED 后调用。")]),e._v(" "),t("li",[e._v("一个 primose 可绑定多个 then 方法")]),e._v(" "),t("li",[e._v("then方法可以同步调用也可以异步调用")]),e._v(" "),t("li",[e._v("同步调用：状态已经改变，直接调用 onFulfilled 方法")]),e._v(" "),t("li",[e._v("异步调用：状态还是PENDING，将 onFulfilled、onRejected 分别加入两个函数数组 onFulfilledCallbacks、onRejectedCallbacks ，当异步调用 resolve 和 reject 时，将两个数组中绑定的事件循环执行。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(executor) {\n    this.state = PENDING;\n    this.value = null;\n    this.reason = null;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    const resolve = (value) => {\n        if(this.state == PENDING) {\n            this.state = FULFILLED;\n            this.value = value;\n            this.onFulfilledCallbacks.forEach(fun => {\n                fun();\n            })\n        }\n    }\n\n    const reject = (reason) => {\n        if(this.state == PENDING) {\n            this.state = REJECTED;\n            this.reason = reason;\n            this.onRejectedCallbacks.forEach(fun => {\n                fun();\n            })\n        }\n    }\n\n    try{\n        executor(resolve, reject);\n    } catch (reason) {\n        reject(reason);\n    }\n}\n\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n    switch(this.state) {\n        case FULFILLED:\n            onRejected(this.value);\n            break;\n        case REJECTED:\n            onFulfilled(this.value);\n            break;\n        case PENDING:\n            this.onFulfilledCallbacks.push(() => {\n                onFulfilled(this.value);\n            })\n            this.onRejectedCallbacks.push(() => {\n                onRejected(this.reason);\n            })\n            break;\n    }\n}\n")])])]),t("h2",{attrs:{id:"then方法异步调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then方法异步调用"}},[e._v("#")]),e._v(" then方法异步调用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(1)\n\nlet promise = new Promise((resolve, reject) => {\n    resolve('resolve')\n})\n\npromise.then(value => {\n    console.log(value)\n})\n\nconsole.log(2)\n// 1\n// 2\n// resolve\n")])])]),t("p",[e._v("虽然resolve是同步执行的，我们必须保证then是异步调用的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.then = function(onFulfilled, onRejected) {\n    if(typeof onFulfilled != 'function') {\n        onFulfilled = function (value) {\n            return value;\n        }\n    }\n    if(typeof onRejected != 'function') {\n        onRejected = function(reason) {\n            return reason;\n        }\n    }\n    switch(this.state) {\n        case FULFILLED:\n            setTimeout(() => {\n                onFulfilled(this.value);\n            }, 0);\n            break;\n        case REJECTED:\n            setTimeout(() => {\n                onRejected(this.reason);\n            }, 0)\n            break;\n        case PENDING:\n            this.onFulfilledCallbacks.push(() => {\n                setTimeout(() => {\n                    onFulfilled(this.value)\n                }, 0)\n            })\n            this.onRejectedCallbacks.push(() => {\n                setTimeout(() => {\n                    onRejected(this.reason)\n                }, 0)\n            })\n            break;\n    }\n}\n")])])]),t("h2",{attrs:{id:"then方法链式调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then方法链式调用"}},[e._v("#")]),e._v(" then方法链式调用")]),e._v(" "),t("p",[e._v("保证链式调用，即 then 方法中要返回一个新的promise，并将 then 方法的返回值进行 resolve 。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.then = function(onFulfilled, onRejected) {\n    if(typeof onFulfilled != 'function') {\n        onFulfilled = function(value) {\n            return value;\n        }\n    }\n    if(typeof onRejected != 'function') {\n        onRejected = function(reason) {\n            return reason;\n        }\n    }\n    const promise2 = new MyPromise((resolve, reject) => {\n        switch(this.state) {\n            case FULFILLED: \n                setTimeout(() => {\n                    try {\n                        const x = onFulfilled(this.value);\n                        resolve(x)\n                    } catch(reason) {\n                        reject(reason)\n                    }\n                }, 0)\n                break;\n            case REJECTED: \n                setTimeout(() => {\n                    try {\n                        const x = onRejected(this.reason);\n                        resolve(x)\n                    } catch(reason) {\n                        reject(reason)\n                    }\n                }, 0)\n                break;\n            case PENDING: \n                this.onFulfilledCallbacks.push(() => {\n                    setTimeout(() => {\n                        try {\n                            const x = onFulfilled(this.value)\n                            resolve(x)\n                        } catch(reason) {\n                            reject(reason)\n                        }\n                    }, 0)\n                })\n                this.onRejectedCallbacks.push(() => {\n                    setTimeout(() => {\n                        try {\n                            const x = onRejected(this.reason)\n                            resolve(x)\n                        } catch(reason) {\n                            reject(reason)\n                        }\n                    }, 0)\n                })\n                break;\n        }\n    })\n    return promise2;\n})\n")])])]),t("h2",{attrs:{id:"catch-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#catch-方法"}},[e._v("#")]),e._v(" catch 方法")]),e._v(" "),t("p",[e._v("若上面没有定义 reject 方法，所有的异常都会走向 catch 方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected);\n}\n")])])]),t("h2",{attrs:{id:"finally-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finally-方法"}},[e._v("#")]),e._v(" finally 方法")]),e._v(" "),t("p",[e._v("不管是 resolve 还是 reject 都会调用 finally")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.finally = function(fn) {\n    return this.then(value => {\n        fn();\n        return value;\n    }, reason => {\n        fn();\n        throw reason;\n    })\n}\n")])])]),t("h2",{attrs:{id:"promise-resolve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" Promise.resolve")]),e._v(" "),t("p",[e._v("用来生成一个直接处于 FULFILLED 状态的Promise.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.resolve = function(value) {\n    return new myPromise((resolve, reject) => {\n        resolve(value);\n    })\n}\n")])])]),t("h2",{attrs:{id:"promise-reject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject")]),e._v(" "),t("p",[e._v("用来生成一个直接处于 REJECTED 状态的Promise.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.reject = function(reason) {\n    return new myPromise((resolve, reject) => {\n        reject(reason);\n    })\n}\n")])])]),t("h2",{attrs:{id:"all方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#all方法"}},[e._v("#")]),e._v(" all方法")]),e._v(" "),t("p",[e._v("接受一个 promise 数组，当所有 promise 状态 resolve 后，执行 resolve.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.all = function(promises) {\n    return new Promise((resolve, reject) => {\n        if(promises.length === 0) {\n            resolve([]);\n        } else {\n            let result = [];\n            let index = 0;\n            for(let i = 0; i < promises.length; i ++) {\n                promises[i].then(data => {\n                    result[i] = data;\n                    if(++index == promises.length) {\n                        resolve(result);\n                    }\n                }, err => {\n                    reject(err);\n                    return;\n                })\n            }\n        }\n    })\n}\n")])])]),t("h2",{attrs:{id:"race-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#race-方法"}},[e._v("#")]),e._v(" race 方法")]),e._v(" "),t("p",[e._v("接受一个 promise 数组，当有一个 promise 状态 resolve 后，执行 resolve.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.race = function(promisess) {\n    return new Promise((resolve, reject) => {\n        if(promises.length === 0) {\n            resolve();\n        } else {\n            let index = 0;\n            for(let i = 0; i < promises.length; i ++) {\n                promises[i].then(data => {\n                    resolve(data);\n                }, err => {\n                    reject(err);\n                    return;\n                })\n            }\n        }\n    })\n}\n")])])]),e._v(" "),t("comment-comment")],1)}),[],!1,null,null,null);n.default=a.exports}}]);