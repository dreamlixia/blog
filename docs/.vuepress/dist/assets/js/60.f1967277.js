(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{593:function(s,r,e){"use strict";e.r(r);var t=e(76),a=Object(t.a)({},(function(){var s=this,r=s.$createElement,e=s._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h3",{attrs:{id:"ssr-server-side-rendering-服务端渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssr-server-side-rendering-服务端渲染"}},[s._v("#")]),s._v(" SSR(Server-Side Rendering): 服务端渲染")]),s._v(" "),e("hr"),s._v(" "),e("h2",{attrs:{id:"_1-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[s._v("#")]),s._v(" 1.概念")]),s._v(" "),e("p",[s._v("Vue是构建客户端应用程序的框架。默认情况下，可以在浏览器输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的HTML字符串，将他们直接发送到浏览器，最后将这些静态标记直接“激活”为客户端上完全可以交互的应用程序。")]),s._v(" "),e("p",[s._v("一个由服务端渲染的Vue.js应用，也可以认为是同构的或通用的，因为应用的大部分代码同时运行在服务端和客户端。")]),s._v(" "),e("h2",{attrs:{id:"_2-ssr优势-为什么要用ssr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-ssr优势-为什么要用ssr"}},[s._v("#")]),s._v(" 2.SSR优势（为什么要用SSR？）")]),s._v(" "),e("ul",[e("li",[s._v("首屏加载更快：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的HTML无需等待所有的js文件下载并执行完成后才显示，所以用户将更早的看到渲染的页面。")]),s._v(" "),e("li",[s._v("统一的心智模型：你可以使用相同的语言、相同的声明式、面向组件的心智模型来开发整个应用，不需要在后端模板系统和前端框架之间来回切换。")]),s._v(" "),e("li",[s._v("更好的seo：搜索引擎优先爬取级别是页面的html结构，当我们使用ssr的时候，服务端已经生成了与业务相关的html，这样对seo是非常友好的。")])]),s._v(" "),e("h2",{attrs:{id:"_3-ssr劣势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-ssr劣势"}},[s._v("#")]),s._v(" 3.SSR劣势")]),s._v(" "),e("ul",[e("li",[s._v("开发中的限制：浏览器端的代码只能在某些特定的生命周期钩子中使用，一些外部库可能需要特殊的处理才能在服务端渲染的应用中运行。")]),s._v(" "),e("li",[s._v("更多的构建和部署相关的要求：需要兼容代码在不同的环境中运行，ssr需要的服务端环境是node，一些客户端对象比如dom，windows之类的可能无法使用，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。")]),s._v(" "),e("li",[s._v("服务端负载更高：相对于前后端分离模式下服务器只需要提供静态资源来说，ssr所需要的服务器负载会更大，所以在项目中使用ssr要慎重，比如用户不是很在乎初始加载的前几秒时，可以用骨架屏或懒加载代替，提升用户体验。")])]),s._v(" "),e("comment-comment")],1)}),[],!1,null,null,null);r.default=a.exports}}]);