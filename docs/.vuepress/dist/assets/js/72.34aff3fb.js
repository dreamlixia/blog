(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{495:function(n,t,e){"use strict";e.r(t);var r=e(27),s=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"判断回文数-判断字符串是否对称"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断回文数-判断字符串是否对称"}},[n._v("#")]),n._v(" 判断回文数/判断字符串是否对称")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n* 判断回文数:\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n* 输入：x = 121\n* 输出：true\n* 输入：x = -121\n* 输出：false\n* 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n*/\n/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    var num = String(x);\n    var leftP = 0;\n    var rightP = num.length - 1;\n    while(leftP < rightP){\n        if(num[leftP] != num[rightP]){\n            return false\n        }\n        leftP ++\n        rightP --\n    }\n    return true\n};\n\nvar result = isPalindrome(1021)\n// true\n")])])]),e("h2",{attrs:{id:"两数之和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两数之和"}},[n._v("#")]),n._v(" 两数之和")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]\n*/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n// 解题：\n// 枚举每一个数为x，遍历寻找数组中是否存在 target - x\nvar twoSum = function(nums, target) {\n    for(var i = 0; i < nums.length; i ++){\n        for(var j = i + 1; j < nums.length; j ++){\n            if(nums[i] === target - nums[j]){\n                return [i, j]\n            }\n        }\n    }\n\n};\n\nvar nums = [22, 45, 3, 87, 4, 0, 76]\nvar result = twoSum(nums, 3)\nconsole.log(result)\n// [2, 5]\n")])])]),e("h2",{attrs:{id:"字符串翻转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串翻转"}},[n._v("#")]),n._v(" 字符串翻转")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function reverseStr(str) {\n    // 字符串转化为数组\n    let list = str.split('')\n    let len = list.length\n    // 定义左右指针，左从下标0开始，右从最后一位下标开始\n    let left_p = 0\n    let right_p = len - 1\n    // 定义条件\n    while (left_p < right_p) {\n        // 定义一个容器去存放第一个要替换位置的元素\n        let tem = list[left_p]\n        // 左替换为右\n        list[left_p] = list[right_p]\n        // 右替换为左\n        list[right_p] = tem\n        // 左指针递增\n        left_p++\n        // 右指针递减\n        right_p--\n    }\n    // 转回字符串\n    return list.join('')\n}\n\nlet str = '题法算转翻串符字道一是这'\n\nconsole.log(reverseStr(str))\n\n// 这是一道字符串翻转算法题\n")])])]),e("h2",{attrs:{id:"js快排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js快排"}},[n._v("#")]),n._v(" js快排")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function sort(arr) {\n    // 临界条件\n    if (arr.length <= 1) return arr\n    // 取基准点\n    let index = Math.floor(arr.length / 2)\n    // 取基准元素\n    let cur = arr.splice(index, 1)[0]\n    // 定义两个数组\n    let left = []\n    let right = []\n    // 循环\n    for (var i = 0; i < arr.length; i++) {\n        // 元素小于基准元素，追加到left[]\n        // 元素大于基准元素，追加到right[]\n        if (arr[i] < cur) {\n            left.push(arr[i])\n        } else {\n            right.push(arr[i])\n        }\n    }\n    // 递归\n    return sort(left).concat([cur], sort(right))\n}\n\nvar arr = [3, 10, 4, 5, 6, 23, 50, 12, 44, 9]\n\nconsole.log(sort(arr))\n\n//[3, 4, 5, 6, 9, 10, 12, 23, 44, 50]\n")])])]),e("h2",{attrs:{id:"罗马数字转整数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#罗马数字转整数"}},[n._v("#")]),n._v(" 罗马数字转整数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n特殊情况\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n*/\n/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    let eg = {\n        'I': 1,\n        'IV': 4,\n        'V': 5,\n        'IX': 9,\n        'X': 10,\n        'XL': 40,\n        'L': 50,\n        'XC': 90,\n        'C': 100,\n        'CD': 400,\n        'D': 500,\n        'CM': 900,\n        'M': 1000\n    }\n    let sum = 0\n    for(var i = 0; i < s.length;) {\n        if(i + 1 < s.length && eg[s.substring(i, i + 2)]) {\n            sum += eg[s.substring(i, i + 2)]\n            i += 2\n        }else{\n            sum += eg[s.substring(i, i + 1)]\n            i ++\n        }\n    }\n    return sum\n};\ns = \"MCMXCIV\"//\"IX\"//\"IV\"//\"XII\"//\"IV\"//\"III\"\nvar result = romanToInt(s)\nconsole.log(result) // 1994\n")])])]),e("h2",{attrs:{id:"合并两个有序链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合并两个有序链表"}},[n._v("#")]),n._v(" 合并两个有序链表")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\n\n// 迭代\nfunction mergeTwoList(l1, l2) {\n    const head = {next: null}\n    let p = head\n    while(l1 && l2){\n        if(l1.val < l2.val){\n            p.next = l1\n            l1 = l1.next\n        }else{\n            p.next = l2\n            l2 = l2.next\n        }\n        p = p.next\n    }\n    p.next = l1 === null ? l2 : l1\n    return head.next\n}\n\n// 递归\nfunction mergeTwoLists(l1, l2) {\n    if(l1 === null) {\n        return l2\n    }\n    if(l2 === null) {\n        return l1\n    }\n    if(l1.val < l2.val){\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    }else{\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n    }\n}\n\nvar l1 = [1,2,4]\nvar l2 = [1,3,4]\nconsole.log(mergeTwoLists(l1, l2)) // [1,1,2,3,4,4]\n")])])]),e("h2",{attrs:{id:"对角线打印二维数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对角线打印二维数组"}},[n._v("#")]),n._v(" 对角线打印二维数组")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function findDiagonalOrder (nums) {\n    if(!nums.length) return []\n    let arr = [], result = []\n    for(var i = 0; i < nums.length; i ++){\n        let rows = nums[i]\n        for(var j = 0; j < rows.length; j ++){\n            if(!arr[i+j]) arr[i+j] = []\n            arr[i+j].push(nums[i][j])\n        }\n    }\n    for(const rows of arr){\n        console.log('rows', rows)\n        result.push(...rows.reverse())\n    }\n    return result\n}\nvar list = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n]\n// console.log(findDiagonalOrder(list))\n// VM301525:18 rows [1]\n// VM301525:18 rows (2) [2, 5]\n// VM301525:18 rows (3) [3, 6, 9]\n// VM301525:18 rows (4) [4, 7, 10, 13]\n// VM301525:18 rows (3) [8, 11, 14]\n// VM301525:18 rows (2) [12, 15]\n// VM301525:18 rows [16]\n// VM301525:23 (16) [1, 5, 2, 9, 6, 3, 13, 10, 7, 4, 14, 11, 8, 15, 12, 16]\n")])])]),e("h2",{attrs:{id:"二维数组扁平化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二维数组扁平化"}},[n._v("#")]),n._v(" 二维数组扁平化")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[][]} nums\n * @return {number[]}\n */\n var findDiagonalOrder = function (nums) {\n    if (nums.length === 0) return [];\n    let arrays = [], result = [];\n      // 根据下标和 聚类\n    for (let i = 0; i < nums.length; i++) {\n      let rows = nums[i];\n      for (let j = 0; j < rows.length; j++) {\n        if (!arrays[i + j]) arrays[i + j] = [];\n        arrays[i + j].push(nums[i][j]);\n      }\n    } \n    // 二维数组扁平化\n    for (const rows of arrays) {\n      result.push(...rows.reverse()); //注意这里每个子数组都是倒序的，需要反转\n    }\n    return result;\n  };\n\n//             [[1,2,3],                                 1\n//              [4,5,6],    变成树                 4             2\n//              [7,8,9]]                     7         5      null 3\n//                                      null    8    null 6\n//                                            null 9\nvar findDiagonalOrder = function(nums) {\n    if(!nums||nums[0].length===0)return []\n    let m=nums.length,queue=[],ans=[]\n    //队列中存放的是个数组[元素值，行号，列号]，之所以这样是因为我们没有必要真的去构建一棵树\n    //对于[a,i,j],他的左孩子就是[b,i+1,j],右孩子就是[c,i,j+1]\n    queue.push([nums[0][0],0,0])\n    while (queue.length>0){\n        let data=queue.shift() //取出首元素\n        ans.push(data[0]) //记录\n        let i=data[1]+1,j=data[2]+1\n        if(i<m&&data[2]<nums[i].length&&data[2]===0){ //左孩子如果有加入\n            queue.push([nums[i][data[2]],i,data[2]])\n        }\n        if(data[1]<m&&j<nums[data[1]].length){ //右孩子如果有加入\n            queue.push([nums[data[1]][j],data[1],j])\n        }\n    }\n    return ans\n};\n")])])]),e("h2",{attrs:{id:"打印-生成有效括号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#打印-生成有效括号"}},[n._v("#")]),n._v(" 打印/生成有效括号")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/** 题目：\n * 输入1，输出['()']\n * 输入2，输出['()()', '(())']\n * 输入3，输出['()()()', '(()())', '(())()', '()(())', '((()))']\n */\n\nlist: 存放最终输出结果的数组\nleft: 已经生成的做括号个数\nright: 已经生成的右括号个数\nn: 需要生成括号的个数\nresult: 已经生成好的括号结果\n\nfunction print(n) {\n    let list = []\n    function generate (left, right, n, result) {\n        // 如果left和right都已经生成够了n个，则返回result\n        if(left == n && right == n) {\n            list.push(result)\n        }\n        // 如果left<n, 则生成一个左括号, left + 1, 递归\n        if(left < n) {\n            generate(left + 1, right, n, result+'(')\n        }\n        // 如果left>right(括号合法问题，先左后右), 并且right<n, 则生成一个右括号, right + 1, 递归\n        if(left > right && right < n) {\n            generate(left, right + 1, n , result+')')\n        }\n    }\n    generate(0, 0, n, \"\")\n    return list\n}\n")])])]),e("h2",{attrs:{id:"判断有效的括号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断有效的括号"}},[n._v("#")]),n._v(" 判断有效的括号")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/*\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n*/\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(str) {\n    \n};\n")])])]),e("h2",{attrs:{id:"杨辉三角"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#杨辉三角"}},[n._v("#")]),n._v(" 杨辉三角")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let generate = function(n) {\n    if(!n) return []\n    let list = [[1]]\n    for(let i = 1; i < n; i ++) {\n        list[i] = []\n        for(let j = 0; j < i+1; j ++) {\n            list[i][j] = (list[i-1][j] || 0) + (list[i-1][j-1] || 0)\n        }\n    }\n    return list\n}\n/*\n0: [1]\n1: (2) [1, 1]\n2: (3) [1, 2, 1]\n3: (4) [1, 3, 3, 1]\n4: (5) [1, 4, 6, 4, 1]\n*/\n")])])]),n._v(" "),e("comment-comment")],1)}),[],!1,null,null,null);t.default=s.exports}}]);