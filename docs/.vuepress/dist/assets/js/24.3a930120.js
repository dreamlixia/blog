(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{440:function(t,e,s){"use strict";s.r(e);var _=s(27),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-多路复用"}},[t._v("#")]),t._v(" 1.多路复用")]),t._v(" "),s("p",[t._v("就是一个连接上可以同时传输多个请求&响应（下一个请求不需要等前一个响应返回后再发出；对于响应服务器可以先处理完哪个就返回哪个而不需要按次请求的顺序返回）。")]),t._v(" "),s("h2",{attrs:{id:"_2-和长链接的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-和长链接的区别"}},[t._v("#")]),t._v(" 2.和长链接的区别")]),t._v(" "),s("p",[t._v("长链接在非管道化的情况下后一个请求只能等前一个请求的响应返回之后才可以被发送；在管道化的情况下，请求可以同时发送，服务器可以并行处理，但是响应却是依次返回。导致的问题就是对头阻塞（如果前一个响应的处理时间长或被无限挂起则后面的响应只能等待）& 无法重复实现多路复用，还可能会有服务器缓存响应过多而造成资源浪费的问题（大多数浏览器都是禁用 http1.1 的管道化功能的，要实现并行发送请求只能通过建立多个连接实现）")]),t._v(" "),s("p",[t._v("多路复用则很好的解决了长链接和管道化带来的对头阻塞问题。它允许在单一的 http2 连接上并行交错的传输请求和响应，而不需要顺序一一对应")]),t._v(" "),s("p",[s("strong",[t._v("管道化：")])]),t._v(" "),s("p",[t._v("可以在一个 http 链接上同时发送多个请求 （可以克服同域并行连接限制带来的阻塞）")]),t._v(" "),s("p",[t._v("服务器可以同时处理多个请求，但是必须按照请求的顺序返回结果（即使后面的请求先处理完成也还是需要缓存起来，等前面的请求处理完返回之后再返回）（对头阻塞：如果前一个请求处理的时间过长或者被无线挂起，那么后面的请求就会排队等待）")]),t._v(" "),s("comment-comment")],1)}),[],!1,null,null,null);e.default=a.exports}}]);