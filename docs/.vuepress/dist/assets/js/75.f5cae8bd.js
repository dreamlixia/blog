(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{497:function(n,e,t){"use strict";t.r(e);var r=t(27),s=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"判断回文数-判断字符串是否对称"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断回文数-判断字符串是否对称"}},[n._v("#")]),n._v(" 判断回文数/判断字符串是否对称")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n* 判断回文数:\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n* 输入：x = 121\n* 输出：true\n* 输入：x = -121\n* 输出：false\n* 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n*/\n/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    var num = String(x);\n    var leftP = 0;\n    var rightP = num.length - 1;\n    while(leftP < rightP){\n        if(num[leftP] != num[rightP]){\n            return false\n        }\n        leftP ++\n        rightP --\n    }\n    return true\n};\n\nvar result = isPalindrome(1021)\n// true\n")])])]),t("h2",{attrs:{id:"两数之和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两数之和"}},[n._v("#")]),n._v(" 两数之和")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]\n*/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n// 解题：\n// 枚举每一个数为x，遍历寻找数组中是否存在 target - x\nvar twoSum = function(nums, target) {\n    for(var i = 0; i < nums.length; i ++){\n        for(var j = i + 1; j < nums.length; j ++){\n            if(nums[i] === target - nums[j]){\n                return [i, j]\n            }\n        }\n    }\n\n};\n\nvar nums = [22, 45, 3, 87, 4, 0, 76]\nvar result = twoSum(nums, 3)\nconsole.log(result)\n// [2, 5]\n")])])]),t("h2",{attrs:{id:"字符串翻转"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串翻转"}},[n._v("#")]),n._v(" 字符串翻转")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function reverseStr(str) {\n    // 字符串转化为数组\n    let list = str.split('')\n    let len = list.length\n    // 定义左右指针，左从下标0开始，右从最后一位下标开始\n    let left_p = 0\n    let right_p = len - 1\n    // 定义条件\n    while (left_p < right_p) {\n        // 定义一个容器去存放第一个要替换位置的元素\n        let tem = list[left_p]\n        // 左替换为右\n        list[left_p] = list[right_p]\n        // 右替换为左\n        list[right_p] = tem\n        // 左指针递增\n        left_p++\n        // 右指针递减\n        right_p--\n    }\n    // 转回字符串\n    return list.join('')\n}\n\nlet str = '题法算转翻串符字道一是这'\n\nconsole.log(reverseStr(str))\n\n// 这是一道字符串翻转算法题\n")])])]),t("h2",{attrs:{id:"js快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js快速排序"}},[n._v("#")]),n._v(" js快速排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function sort(arr) {\n    // 临界条件\n    if (arr.length <= 1) return arr\n    // 取基准点\n    let index = Math.floor(arr.length / 2)\n    // 取基准元素\n    let cur = arr.splice(index, 1)[0]\n    // 定义两个数组\n    let left = []\n    let right = []\n    // 循环\n    for (var i = 0; i < arr.length; i++) {\n        // 元素小于基准元素，追加到left[]\n        // 元素大于基准元素，追加到right[]\n        if (arr[i] < cur) {\n            left.push(arr[i])\n        } else {\n            right.push(arr[i])\n        }\n    }\n    // 递归\n    return sort(left).concat([cur], sort(right))\n}\n\nvar arr = [3, 10, 4, 5, 6, 23, 50, 12, 44, 9]\n\nconsole.log(sort(arr))\n\n//[3, 4, 5, 6, 9, 10, 12, 23, 44, 50]\n")])])]),t("h2",{attrs:{id:"罗马数字转整数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#罗马数字转整数"}},[n._v("#")]),n._v(" 罗马数字转整数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n特殊情况\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n*/\n/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    let eg = {\n        'I': 1,\n        'IV': 4,\n        'V': 5,\n        'IX': 9,\n        'X': 10,\n        'XL': 40,\n        'L': 50,\n        'XC': 90,\n        'C': 100,\n        'CD': 400,\n        'D': 500,\n        'CM': 900,\n        'M': 1000\n    }\n    let sum = 0\n    for(var i = 0; i < s.length;) {\n        if(i + 1 < s.length && eg[s.substring(i, i + 2)]) {\n            sum += eg[s.substring(i, i + 2)]\n            i += 2\n        }else{\n            sum += eg[s.substring(i, i + 1)]\n            i ++\n        }\n    }\n    return sum\n};\ns = \"MCMXCIV\"//\"IX\"//\"IV\"//\"XII\"//\"IV\"//\"III\"\nvar result = romanToInt(s)\nconsole.log(result) // 1994\n")])])]),t("h2",{attrs:{id:"合并两个有序链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并两个有序链表"}},[n._v("#")]),n._v(" 合并两个有序链表")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\n\n// 迭代\nfunction mergeTwoList(l1, l2) {\n    const head = {next: null}\n    let p = head\n    while(l1 && l2){\n        if(l1.val < l2.val){\n            p.next = l1\n            l1 = l1.next\n        }else{\n            p.next = l2\n            l2 = l2.next\n        }\n        p = p.next\n    }\n    p.next = l1 === null ? l2 : l1\n    return head.next\n}\n\n// 递归\nfunction mergeTwoLists(l1, l2) {\n    if(l1 === null) {\n        return l2\n    }\n    if(l2 === null) {\n        return l1\n    }\n    if(l1.val < l2.val){\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    }else{\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n    }\n}\n\nvar l1 = [1,2,4]\nvar l2 = [1,3,4]\nconsole.log(mergeTwoLists(l1, l2)) // [1,1,2,3,4,4]\n")])])]),t("h2",{attrs:{id:"对角线打印二维数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对角线打印二维数组"}},[n._v("#")]),n._v(" 对角线打印二维数组")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function findDiagonalOrder (nums) {\n    if(!nums.length) return []\n    let arr = [], result = []\n    for(var i = 0; i < nums.length; i ++){\n        let rows = nums[i]\n        for(var j = 0; j < rows.length; j ++){\n            if(!arr[i+j]) arr[i+j] = []\n            arr[i+j].push(nums[i][j])\n        }\n    }\n    for(const rows of arr){\n        console.log('rows', rows)\n        result.push(...rows.reverse())\n    }\n    return result\n}\nvar list = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n]\n// console.log(findDiagonalOrder(list))\n// VM301525:18 rows [1]\n// VM301525:18 rows (2) [2, 5]\n// VM301525:18 rows (3) [3, 6, 9]\n// VM301525:18 rows (4) [4, 7, 10, 13]\n// VM301525:18 rows (3) [8, 11, 14]\n// VM301525:18 rows (2) [12, 15]\n// VM301525:18 rows [16]\n// VM301525:23 (16) [1, 5, 2, 9, 6, 3, 13, 10, 7, 4, 14, 11, 8, 15, 12, 16]\n")])])]),t("h2",{attrs:{id:"二维数组扁平化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二维数组扁平化"}},[n._v("#")]),n._v(" 二维数组扁平化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * @param {number[][]} nums\n * @return {number[]}\n */\n var findDiagonalOrder = function (nums) {\n    if (nums.length === 0) return [];\n    let arrays = [], result = [];\n      // 根据下标和 聚类\n    for (let i = 0; i < nums.length; i++) {\n      let rows = nums[i];\n      for (let j = 0; j < rows.length; j++) {\n        if (!arrays[i + j]) arrays[i + j] = [];\n        arrays[i + j].push(nums[i][j]);\n      }\n    } \n    // 二维数组扁平化\n    for (const rows of arrays) {\n      result.push(...rows.reverse()); //注意这里每个子数组都是倒序的，需要反转\n    }\n    return result;\n  };\n\n//             [[1,2,3],                                 1\n//              [4,5,6],    变成树                 4             2\n//              [7,8,9]]                     7         5      null 3\n//                                      null    8    null 6\n//                                            null 9\nvar findDiagonalOrder = function(nums) {\n    if(!nums||nums[0].length===0)return []\n    let m=nums.length,queue=[],ans=[]\n    //队列中存放的是个数组[元素值，行号，列号]，之所以这样是因为我们没有必要真的去构建一棵树\n    //对于[a,i,j],他的左孩子就是[b,i+1,j],右孩子就是[c,i,j+1]\n    queue.push([nums[0][0],0,0])\n    while (queue.length>0){\n        let data=queue.shift() //取出首元素\n        ans.push(data[0]) //记录\n        let i=data[1]+1,j=data[2]+1\n        if(i<m&&data[2]<nums[i].length&&data[2]===0){ //左孩子如果有加入\n            queue.push([nums[i][data[2]],i,data[2]])\n        }\n        if(data[1]<m&&j<nums[data[1]].length){ //右孩子如果有加入\n            queue.push([nums[data[1]][j],data[1],j])\n        }\n    }\n    return ans\n};\n")])])]),t("h2",{attrs:{id:"打印-生成有效括号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打印-生成有效括号"}},[n._v("#")]),n._v(" 打印/生成有效括号")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/** 题目：\n * 输入1，输出['()']\n * 输入2，输出['()()', '(())']\n * 输入3，输出['()()()', '(()())', '(())()', '()(())', '((()))']\n */\n\nlist: 存放最终输出结果的数组\nleft: 已经生成的做括号个数\nright: 已经生成的右括号个数\nn: 需要生成括号的个数\nresult: 已经生成好的括号结果\n\nfunction print(n) {\n    let list = []\n    function generate (left, right, n, result) {\n        // 如果left和right都已经生成够了n个，则返回result\n        if(left == n && right == n) {\n            list.push(result)\n        }\n        // 如果left<n, 则生成一个左括号, left + 1, 递归\n        if(left < n) {\n            generate(left + 1, right, n, result+'(')\n        }\n        // 如果left>right(括号合法问题，先左后右), 并且right<n, 则生成一个右括号, right + 1, 递归\n        if(left > right && right < n) {\n            generate(left, right + 1, n , result+')')\n        }\n    }\n    generate(0, 0, n, \"\")\n    return list\n}\n")])])]),t("h2",{attrs:{id:"判断有效的括号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断有效的括号"}},[n._v("#")]),n._v(" 判断有效的括号")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/*\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n*/\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(str) {\n    \n};\n")])])]),t("h2",{attrs:{id:"杨辉三角"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#杨辉三角"}},[n._v("#")]),n._v(" 杨辉三角")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let generate = function(n) {\n    if(!n) return []\n    let list = [[1]]\n    for(let i = 1; i < n; i ++) {\n        list[i] = []\n        for(let j = 0; j < i+1; j ++) {\n            list[i][j] = (list[i-1][j] || 0) + (list[i-1][j-1] || 0)\n        }\n    }\n    return list\n}\n/*\n0: [1]\n1: (2) [1, 1]\n2: (3) [1, 2, 1]\n3: (4) [1, 3, 3, 1]\n4: (5) [1, 4, 6, 4, 1]\n*/\n")])])]),t("h2",{attrs:{id:"翻转字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#翻转字符串"}},[n._v("#")]),n._v(" 翻转字符串")]),n._v(" "),t("p",[n._v("编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。")]),n._v(" "),t("p",[n._v("不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('输入：s = ["h","e","l","l","o"]\n输出：["o","l","l","e","h"]\n\nvar reverseList = function(s) {\n    let n = s.length;\n    for(var left = 0, right = n - 1; left < right; ++ left, -- right){\n        [s[left], s[right]] = [s[right], s[left]]\n    }\n}\n')])])]),t("h2",{attrs:{id:"链表反转2-反转中间区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表反转2-反转中间区域"}},[n._v("#")]),n._v(" 链表反转2(反转中间区域)")]),n._v(" "),t("p",[n._v("给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。")]),n._v(" "),t("ol",[t("li",[n._v("因为头节点可能发生变化，使用虚拟头节点可以避免复杂的分类讨论； new ListNode(-1)\nconst dummyNode = new ListNode(-1);\ndummyNode.next = head;\nlet pre = dummyNode;")]),n._v(" "),t("li",[n._v("从虚拟头节点走left - 1 步，来到 left 的前一个节点，使用 for 循环；\nfor(let i = 0;  < left - 1; i ++){\npre = pre.next;\n}")]),n._v(" "),t("li",[n._v("从 pre 再走 right-left+1 步，来到 right 节点，使用 for 循环；\nlet rightNode = pre;\nfor(let i = 0; i < right - left + 1; i ++){\nrightNode = rightNode.next;\n}")]),n._v(" "),t("li",[n._v("截取链表；leftNode；\nlet leftNode = pre.next;\nlet curr = rightNode.next;")]),n._v(" "),t("li",[n._v("切断链接（置为null）；\npre.next = null;\nrightNode.next = null;")]),n._v(" "),t("li",[n._v("反转中间区域，同反转链表1题解；转leftNode；\nvar reverseList = function(head) {\nlet prev = null;\nlet cur = head;\nwhile(cur){\nconst next = cur.next;\ncur.next = prev;\nprev = cur;\ncur = next;\n}\nreturn prev;\n}")]),n._v(" "),t("li",[n._v("接回到原来的链表中\npre.next = rightNode;\nleftNode.next = curr;\nreturn dummyNode.next;")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var reverseBetween = function(head, left, right) {\n    // 虚拟头节点\n    const dummyNode = new ListNode(-1);\n    dummyNode.next = head;\n    \n    let pre = dummyNode;\n    // 从pre走到left-1节点；\n    for(let i = 0; i < left - 1; i ++){\n        pre = pre.next;\n    }\n    // 从pre走right-left+1步到right节点\n    let rightNode = pre;\n    for(let i = 0; i < right - left + 1; i ++){\n        rightNode = rightNode.next;\n    }\n    // 截取子区间\n    let leftNode = pre.next;\n    let curr = rightNode.next;\n    // 切断\n    pre.next = null;\n    rightNode.next = null;\n    // 反转子区间\n    reverseList(leftNode);\n    // 拼接\n    pre.next = rightNode;\n    leftNode.next = curr;\n    return dummyNode.next;\n};\nconst reverseList = function(head) {\n    let prev = null;\n    let cur = head;\n    while(cur){\n        const next = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = next;\n    }\n    return prev;\n}\n")])])]),t("h2",{attrs:{id:"一堆数组的动态和-动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一堆数组的动态和-动态规划"}},[n._v("#")]),n._v(" 一堆数组的动态和（动态规划）")]),n._v(" "),t("p",[n._v("输入： [1,2,3,4,5]\n输出： [1,3,6,10,15]")]),n._v(" "),t("p",[n._v("输入：[1,1,1,1,1]\n输出：[1,2,3,4,5]")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var runningSum = function(nums){\n    let n = nums.length;\n    for(let i = 1; i < n; i ++){\n        nums[i] += nums[i-1]\n    }\n    return nums;\n}\n")])])]),t("h2",{attrs:{id:"滑动窗口-动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口-动态规划"}},[n._v("#")]),n._v(" 滑动窗口（动态规划）")]),n._v(" "),t("p",[n._v("给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。")]),n._v(" "),t("p",[n._v("实现 MovingAverage 类：")]),n._v(" "),t("p",[n._v("MovingAverage(int size) 用窗口大小 size 初始化对象。\ndouble next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。")]),n._v(" "),t("p",[n._v("参考资料： https://zhuanlan.zhihu.com/p/419498264")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var MovingAverage = function(size) {\n    this.nums = []; // 队列初始化\n    this.capacity = size; // 窗口长度\n    this.sum = 0; // 总和\n}\n\nMovingAverage.prototype.next = function(val) {\n    this.nums.push(val);\n    this.sum += val;\n    if(this.nums.length > this.capacity) {\n        this.sum -= this.nums.shift();\n    }\n    return this.sum / this.nums.length;\n}\n")])])]),t("h2",{attrs:{id:"剑指-offer-06-从尾到头打印链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剑指-offer-06-从尾到头打印链表"}},[n._v("#")]),n._v(" 剑指 Offer 06. 从尾到头打印链表")]),n._v(" "),t("p",[n._v("输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。")]),n._v(" "),t("p",[n._v("示例 1：")]),n._v(" "),t("p",[n._v("输入：head = [1,3,2]\n输出：[2,3,1]\n")]),t("div",{staticStyle:{display:"none"}},[t("p"),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 第一种\nvar reversePrint = function(head) {\n    let nodes = []\n    while(head != null) {\n        nodes.push(head.val)\n        head = head.next\n    }\n    return nodes.reverse()\n}\n// 第二种\nvar reversePrint = function(head) {\n    let nodes = []\n    while(head != null){\n        nodes.push(head.val)\n        head = head.next\n    }\n    let result = []\n    let temp = nodes.pop()\n    while(temp != null){\n        result.push(temp)\n        temp = nodes.pop()\n    }\n    return result;\n}\n")])])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var reversePrint = function(head) {\n    // 定义一个装节点的数组遍历出来\n    let nodes = [];\n    while(head != null){\n        // push 进去，head后移一位\n        nodes.push(head.val);\n        head = head.next;\n    }\n    // 第一种\n        // 后删，每删除一个就push进结果数组\n        let result = []\n        let temp = nodes.pop()\n        while(temp != null){\n            result.push(temp)\n            temp = nodes.pop()\n        }\n        return result\n    // 第二种\n        // 直接reverse\n        // return nodes.reverse()\n};\n")])])]),t("h2",{attrs:{id:"剑指-offer-18-删除链表的节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剑指-offer-18-删除链表的节点"}},[n._v("#")]),n._v(" 剑指 Offer 18. 删除链表的节点")]),n._v(" "),t("p",[n._v("给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。")]),n._v(" "),t("p",[n._v("返回删除后的链表的头节点。")]),n._v(" "),t("p",[n._v("注意：此题对比原题有改动")]),n._v(" "),t("p",[n._v("示例 1:")]),n._v(" "),t("p",[n._v("输入: head = [4,5,1,9], val = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n示例 2:")]),n._v(" "),t("p",[n._v("输入: head = [4,5,1,9], val = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var deleteNode = function(head, val) {\n    if(head == null) return null\n    if(head.val == val) return head.next\n    let temp = head\n    // 遍历没有找到时\n    while(temp.next && temp.next.val !== val){\n        // 用next右移继续找\n        temp = temp.next\n    }\n    // 如果找到目标值\n    if(temp.next.val === val){\n        // 直接越过这个值去下一个next\n        temp.next = temp.next.next\n    }\n    // 最终返回头节点\n    return head\n}\n")])])]),t("h2",{attrs:{id:"剑指offer-78-合并排序链表-困难"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剑指offer-78-合并排序链表-困难"}},[n._v("#")]),n._v(" 剑指offer 78. 合并排序链表（困难）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 输入：lists = [[1,4,5],[1,3,4],[2,6]]\n    输出：[1,1,2,3,4,4,5,6]\n    解释：链表数组如下：\n    [\n    1->4->5,\n    1->3->4,\n    2->6\n    ]\n    将它们合并到一个有序链表中得到。\n    1->1->2->3->4->4->5->6\n\n    输入：lists = []\n    输出：[]\n\n    输入：lists = [[]]\n    输出：[]\n */\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var mergeKLists = function(lists) {\n    if(lists == null) return null\n    let n = lists.length\n    if(n == 0) return null\n    if(n == 1) return lists[0]\n    for(var i = 1; i < n; i ++) {\n        lists[i] = mergeTwoLists(lists[i-1], lists[i])\n    }\n    return lists[n-1]\n}\n// 先合并两个\nvar mergeTwoLists = function(l1, l2) {\n    let head = new ListNode()\n    let cur =  head\n    while(l1 && l2) {\n        if(l1.val < l2.val) {\n            cur.next = l1\n            l1 = l1.next\n        }else{\n            cur.next = l2\n            l2 = l2.next\n        }\n        // 指针右移\n        cur = cur.next\n    }\n    cur.next = l1 == null ? l2 : l1\n    return head.next\n}\n")])])]),t("h2",{attrs:{id:"_215-数组中的第k个最大元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_215-数组中的第k个最大元素"}},[n._v("#")]),n._v(" 215.数组中的第K个最大元素")]),n._v(" "),t("p",[n._v("给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。")]),n._v(" "),t("p",[n._v("请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。")]),n._v(" "),t("p",[n._v("你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。")]),n._v(" "),t("p",[n._v("示例 1:")]),n._v(" "),t("p",[n._v("输入: [3,2,1,5,6,4], k = 2\n输出: 5")]),n._v(" "),t("p",[n._v("示例 2:")]),n._v(" "),t("p",[n._v("输入: [3,2,3,1,2,4,5,5,6], k = 4\n输出: 4")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var findKthLargest = function(nums, k) {\n    // 先排序，下标为n-k的值即为目标，需考虑负数情况\n    nums.sort((a,b)=>a-b)\n    let n = nums.length\n    for(var i = n-1; i >= 0; --i) {\n        if(n-k == i) {\n            return nums[i]\n        }\n    }\n}\n")])])]),t("h2",{attrs:{id:"回文链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回文链表"}},[n._v("#")]),n._v(" 回文链表")]),n._v(" "),t("p",[n._v("思路：")]),n._v(" "),t("ul",[t("li",[n._v("遍历链表")]),n._v(" "),t("li",[n._v("定义init数组，push进去")]),n._v(" "),t("li",[n._v("双向遍历数组， 比较值")]),n._v(" "),t("li",[n._v("不相等返回false，否则true")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var isPalindrome = function(head) {\n    /**\n     * 定义init数组\n     * 遍历链表\n     */\n    let list = []\n    while(head != null) {\n        list.push(head.val)\n        head = head.next\n    }\n    /**\n     * 双向遍历数组\n     * 比较值\n     */\n    let n = list.length\n    for(var i=0,j=n-1; i<j; i++,j--) {\n        if(list[i] !== list[j]) {\n            return false\n        }\n    }\n    return true\n}\n")])])]),n._v(" "),t("comment-comment")],1)}),[],!1,null,null,null);e.default=s.exports}}]);