(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{527:function(e,t,s){e.exports=s.p+"assets/img/hooks1.f00b4245.jpg"},591:function(e,t,s){"use strict";s.r(t);var n=s(76),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"react-hooks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[e._v("#")]),e._v(" React-Hooks:")]),e._v(" "),n("p",[e._v("是函数组件解决没有state，生命周期，逻辑不能复用的一种技术方案。")]),e._v(" "),n("p",[e._v("Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")]),e._v(" "),n("h2",{attrs:{id:"function和class组件本质的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function和class组件本质的区别"}},[e._v("#")]),e._v(" function和class组件本质的区别：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Index extends Component<any,any>{\n    constructor(props){\n        super(props)\n        this.state = {\n            num: 0\n        }\n    }\n    handleClick = () => {\n        for(let i=0; i< 5; i++ ){\n            setTimeout(()=>{\n                this.setState({number: this.state.num+1})\n                console.log(this.state.num)\n            }, 1000)\n        }\n    }\n    render() {\n        return <div>\n            <div onClick={this.handleClick}>num++</div>\n        </div>\n    }\n}\nexport default Index;\n")])])]),n("p",[e._v("打印结果： 1 2 3 4 5")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Index () {\n    const [num, setNumber] = React.useState(0)\n    const handleClick = () => {\n        for(let i=0; i<5; i++){\n            setTimeout(()=>{\n                setNumber(num+1)\n                console.log(num)\n            }, 1000)\n        }\n    }\n    return <div onClick={handleClick}>{num}</div>\n}\n")])])]),n("p",[e._v("打印结果：0 0 0 0 0")]),e._v(" "),n("p",[n("strong",[e._v("对于class组件，只需要实例化一次，实例中保存了state等状态，每次更新只需要调用render方法即可。但是在function组件中，每一次更新都是一次新的函数执行，为了保存一些状态，执行一些副作用钩子，react-hooks应运而生，去帮助组件记录一些状态，处理一些额外的副作用。")])]),e._v(" "),n("h2",{attrs:{id:"hooks初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hooks初始化"}},[e._v("#")]),e._v(" Hooks初始化：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("useState  // 负责组件更新\nuseEffect // 执行副作用\nuseRef    // 保存数据\nuseMemo   // 缓存优化\n\nuseCallback\nuseReducer\nuseLayoutEffect\n")])])]),n("p",[e._v("示例代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect, useMemo, useRef } from 'react';\n\nfunction Index() {\n    const [number, setNumber] = useState(0);\n    const divDemo = useMemo(() => <div>hello, I am a divDemo.</div>, [])\n    const curRef = useRef(null);\n    useEffect(()=>{\n        console.log(curRef.current)\n    },[])\n    return <div ref={ curRef }>\n        hello world { number }\n        { divDemo }\n        <button onClick={() => setNumber(number+1)}>number ++</button>\n    </div>\n}\n")])])]),n("ol",[n("li",[n("strong",[e._v("mountWorkInProgressHook")])])]),e._v(" "),n("p",[e._v("在组件初始化的时候，每一次hooks执行，如useState(), useEffect(), 都会调用mountWorkInProgressHook.")]),e._v(" "),n("p",[e._v("mountWorkInProgressHook做的事情：首先每次执行一个hooks函数，都产生一个hooks对象，里面保存了当前hook信息，然后将每个hooks以链表形式串联起来，并赋值给workInProgress的memoizedState。也就证明了函数组件用memoizedState存放hooks链表。")]),e._v(" "),n("ul",[n("li",[e._v("memoizedState:\n"),n("ul",[n("li",[e._v("useState：保存state信息")]),e._v(" "),n("li",[e._v("useEffect：保存effect对象")]),e._v(" "),n("li",[e._v("useRef：保存ref对象")]),e._v(" "),n("li",[e._v("useMemo：保存缓存的值和deps")])])]),e._v(" "),n("li",[e._v("baseQueue: useState和useEffect中保存最新的更新队列。")]),e._v(" "),n("li",[e._v("baseState: useState和useEffect中，一次更新中，产生的最新的state值。")]),e._v(" "),n("li",[e._v("queue: 保存待更新队列pendingQueue，更新函数dispatch等信息。")]),e._v(" "),n("li",[e._v("next: 指向下一个hooks对象。\n"),n("div",{staticStyle:{"text-align":"center"}},[n("img",{attrs:{width:"100%",src:s(527),alt:""}})])])]),e._v(" "),n("p",[n("strong",[e._v("不能在条件语句中声明hooks:")]),e._v(" 因为一旦在条件语句中声明hooks，在下一次函数组件更新，hooks链表结构，将会被破坏，current树的memoizedState缓存hooks信息，和当前workInProgress不一致，如果涉及到读取state等操作，就会发生异常。")]),e._v(" "),n("p",[n("font",{attrs:{color:"#dd0000"}},[e._v("🌟总结：hooks是通过什么证明唯一性的？答：通过hooks链表顺序。")])],1),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("strong",[e._v("useState => mountState")])])]),e._v(" "),n("p",[e._v("在无状态组件中，useState和useReducer触发函数更新的方法都是dispatchAction，useState可以看成是一个简版的useReducer。")]),e._v(" "),n("p",[e._v("dispatchAction无状态组件更新机制: dispatchAction就是setNumber。")]),e._v(" "),n("ul",[n("li",[e._v("无论是类组件调用setState，还是函数组件的dispatchAction，都会产生一个update对象，里面记录了此次更新的信息，然后将此update放入待更新的pending队列中。dispatchAction的第二步就是判断当前函数组件的fiber对象是否处于渲染阶段。如果处于渲染阶段，那么不需要我们更新当前函数组件，只需要更新当前的update和expirationTime即可。")]),e._v(" "),n("li",[e._v("如果当前fiber没有处于更新阶段，那么通过调用lastRenderedReducer获取最新state，和上一次的currentState进行浅比较，如果相等，就退出。证实了useState两次值相等的时候组件就不进行渲染了，这和Component模式下的setState有一定的区别。")]),e._v(" "),n("li",[e._v("如果两次state不相等，调用scheduleUpdateOnFiber调度渲染当前fiber，"),n("font",{attrs:{color:"#dd0000"}},[e._v("scheduleUpdateOnFiber")]),e._v("是react渲染更新的主要函数。")],1)]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("strong",[e._v("useEffect => mountEffect")])])]),e._v(" "),n("p",[e._v("每个hooks初始化都会创建一个hook对象，然后将hook的memoizedState保存当前的effect hook信息。")]),e._v(" "),n("p",[e._v("有两个memoizedState不要混淆")]),e._v(" "),n("ul",[n("li",[e._v("workInProgress / current 树上的memoizedState保存的是当前函数组件每个hooks形成的链表。")]),e._v(" "),n("li",[e._v("每个hooks上的memoizedState保存的是当前hooks的信息，不同种类的hooks的memoizedState内容不同。")])]),e._v(" "),n("p",[e._v("pushEffect 创建 effect 对象，挂载 updateQueue")]),e._v(" "),n("p",[e._v("首先创建一个 effect ，判断组件如果第一次渲染，那么创建 componentUpdateQueue ，就是workInProgress的updateQueue。然后将effect放入updateQueue中。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    next: null,\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue\n  if (componentUpdateQueue === null) { // 如果是第一个 useEffect\n    componentUpdateQueue = {  lastEffect: null  }\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {  // 存在多个effect\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n")])])]),n("p",[e._v("内容太多，先不写了……😭")]),e._v(" "),n("p",[n("strong",[e._v("mounted 阶段 hooks 总结")])]),e._v(" "),n("p",[e._v("初始化阶段，react-hooks 做的事情，在一个函数组件第一次渲染执行上下文的过程中，每个 react-hooks 执行，都会产生一个 hook 对象，并形成链表结构，绑定在 workInProgress 的 memoizedState 属性上，然后 react-hooks 上的状态，绑定在当前 hooks 对象的 memoizedState 属性上。对于 effect 副作用钩子，会绑定在 workInProgress.updateQueue 上，等到 commit 阶段，dom 树构建完成，在执行每个 effect 副作用钩子。")]),e._v(" "),n("h2",{attrs:{id:"hooks-更新阶段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hooks-更新阶段"}},[e._v("#")]),e._v(" Hooks 更新阶段")]),e._v(" "),n("p",[e._v("对于更新阶段，说明上一次 workInProgress 树已经赋值给了 current 树。存放hooks信息的memoizedState，此时已经存在current树上，react对于hooks的处理逻辑和fiber树逻辑类似。")]),e._v(" "),n("p",[e._v("对于一次函数组件更新，当再次执行hooks函数的时候，比如 useState(0) ，首先要从current的hooks中找到与当前workInProgressHook，对应的currentHooks，然后复制一份currentHooks给workInProgressHook,接下来hooks函数执行的时候,把最新的状态更新到workInProgressHook，保证hooks状态不丢失。")]),e._v(" "),n("h2",{attrs:{id:"useeffect-不支持关键词-async-的原因"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect-不支持关键词-async-的原因"}},[e._v("#")]),e._v(" useEffect 不支持关键词 async 的原因")]),e._v(" "),n("p",[e._v("使用 async/await 关键词，会返回一个promises，useEffect 的返回的也就是 promise 了。")]),e._v(" "),n("p",[e._v("正确的写法是在 useEffect 内写一个异步函数，然后调用它。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("useEffect(() => {\n    const fetchData = async () => {\n        try {\n            const res = await fetch('xxx/url');\n            const data = await res.json();\n        } catch (e) {\n            console.error('Error: ', error);\n        }\n    };\n\n    fetchData();\n}, [])\n\n")])])]),e._v(" "),n("comment-comment")],1)}),[],!1,null,null,null);t.default=o.exports}}]);