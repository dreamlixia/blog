(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{330:function(t,e,a){"use strict";a.r(e);var l=a(14),r=Object(l.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、var、let、const的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、var、let、const的区别"}},[t._v("#")]),t._v(" 一、var、let、const的区别")]),t._v(" "),e("ol",[e("li",[t._v("var存在变量提升，let和const不存在变量提升，只能先声明，后使用，否则报错；")])]),t._v(" "),e("blockquote",[e("p",[t._v("变量提升：在声明之前就可以输出，值为undefined；")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("let和const是块级作用域，只在声明的作用域内有效；")]),t._v(" "),e("li",[t._v("let可以先声明，后赋值，const声明时必须进行初始化赋值；")]),t._v(" "),e("li",[t._v("let声明变量，const声明常量，const只能进行一次赋值，声明后不可改变，var和let可以修改变量值；")]),t._v(" "),e("li",[t._v("在同一作用域下let和const不能声明同名变量，而var可以重复声明变量；")]),t._v(" "),e("li",[t._v("在es5中，顶层对象的属性和全局变量是等价的，用var声明的对象既是全局变量，也是顶层对象；")])]),t._v(" "),e("blockquote",[e("p",[t._v("顶层对象，在浏览器中指的是window对象，nodejs中指的是global对象；")])]),t._v(" "),e("p",[t._v("能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var")]),t._v(" "),e("h2",{attrs:{id:"二、数组新增拓展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、数组新增拓展"}},[t._v("#")]),t._v(" 二、数组新增拓展")]),t._v(" "),e("ol",[e("li",[t._v("扩展运算符 ...")])]),t._v(" "),e("blockquote",[e("p",[t._v("扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中")])]),t._v(" "),e("ul",[e("li",[t._v("可以将数组转化为参数序列")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let arr = [1, 2, 3]\nconsole.log(...arr) // 1 2 3\n")])])]),e("ul",[e("li",[t._v("可以复制数组")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const arr1 = [1, 2, 3]\nconst arr2 = [...arr1]\nconsole.log(arr2) // [1, 2, 3]\n")])])]),e("ul",[e("li",[t._v("与解构赋值结合起来，生成新数组")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const [first, ...reset] = [1,2,3,4,5]\nconsole.log(first) // 1\nconsole.log(reset) // [2,3,4,5]\n")])])]),e("blockquote",[e("p",[t._v("如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。")])]),t._v(" "),e("ul",[e("li",[t._v("将字符串转化为真正的数组")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('console.log([...\'hello\']) // ["h", "e", "l", "l", "o"]\n')])])]),e("ul",[e("li",[t._v("实现了 Iterator 接口的对象, 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let nodeList = document.querySelectorAll('div');\nlet array = [...nodeList];\n")])])]),e("p",[t._v("上面代码中，querySelectorAll()方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator。")]),t._v(" "),e("blockquote",[e("p",[t._v("把某些数据结构转化为数组")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function foo() {\n   const args = [...arguments];\n}\n")])])]),e("p",[t._v("用于替换es5中的Array.prototype.slice.call(arguments)写法。")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("构造函数新增方法")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Array.from()：将两类对象转化为真正的数组（包括 ES6 新增的数据结构 Set 和 Map）")]),t._v(" "),e("ul",[e("li",[t._v("类似数组的对象")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5 的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6 的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n")])])]),e("p",[t._v("实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from()都可以将它们转为真正的数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// NodeList 对象\nlet ps = document.querySelectorAll('p'); // querySelectorAll()方法返回的是一个类似数组的对象\nArray.from(ps).filter(p => {\n    return p.textContent.length > 100;\n});\n\n// arguments 对象\nfunction foo() {\n    var args = Array.from(arguments);\n    // ...\n}\n")])])]),e("ul",[e("li",[t._v("可遍历（iterable）的对象: 只要是部署了 Iterator 接口的数据结构，Array.from()都能将其转为数组")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n")])])]),e("p",[t._v("上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from()转为真正的数组。")]),t._v(" "),e("blockquote",[e("p",[t._v("Array.from()还可以接受一个函数作为第二个参数，作用类似于数组的map()方法，用来对每个元素进行处理，将处理后的值放入返回的数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n")])])])])]),t._v(" "),e("li",[e("p",[t._v("Array.of(): 用于将一组值，转换为数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n")])])]),e("ul",[e("li",[t._v("没有参数的时候，返回一个空数组")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Array.of() // []\n")])])]),e("ul",[e("li",[t._v("当参数只有一个的时候，实际上是指定数组的长度")]),t._v(" "),e("li",[t._v("参数个数不少于 2 个时，Array()才会返回由参数组成的新数组")])])])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("实例对象新增方法")])]),t._v(" "),e("ul",[e("li",[t._v("copyWithin()：将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组\n"),e("ul",[e("li",[t._v("target（必需）：从该位置开始替换数据。如果为负值，表示倒数。")]),t._v(" "),e("li",[t._v("start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。")]),t._v(" "),e("li",[t._v("end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。")])])]),t._v(" "),e("li",[t._v("find()、findIndex()：find()用于找出第一个符合条件的数组成员\n"),e("ul",[e("li",[t._v("参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组")]),t._v(" "),e("li",[t._v("findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1")]),t._v(" "),e("li",[t._v("这两个方法都可以接受第二个参数，用来绑定回调函数的this对象")])])]),t._v(" "),e("li",[t._v("fill()：使用给定值，填充一个数组\n"),e("ul",[e("li",[t._v("还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置")]),t._v(" "),e("li",[t._v("注意，如果填充的类型为对象，则是浅拷贝")])])]),t._v(" "),e("li",[t._v("entries()，keys()，values()：\n"),e("ul",[e("li",[t._v("keys()是对键名的遍历")]),t._v(" "),e("li",[t._v("values()是对键值的遍历")]),t._v(" "),e("li",[t._v("entries()是对键值对的遍历")])])]),t._v(" "),e("li",[t._v("includes()：用于判断数组是否包含给定的值\n"),e("ul",[e("li",[t._v("方法的第二个参数表示搜索的起始位置，默认为0")]),t._v(" "),e("li",[t._v("参数为负数则表示倒数的位置")])])]),t._v(" "),e("li",[t._v("flat()，flatMap()：将数组扁平化处理，返回一个新数组，对原数据没有影响\n"),e("ul",[e("li",[t._v("flat()：默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1")]),t._v(" "),e("li",[t._v("flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this")])])])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("数组的空位")])]),t._v(" "),e("blockquote",[e("p",[t._v("数组的空位指，数组的某一个位置没有任何值")])]),t._v(" "),e("ul",[e("li",[t._v("es6明确将数组的空位转为undefined")])]),t._v(" "),e("h2",{attrs:{id:"三、对象新增拓展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、对象新增拓展"}},[t._v("#")]),t._v(" 三、对象新增拓展")]),t._v(" "),e("ol",[e("li",[t._v("属性的简写")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var payload = { \n    id: id\n}\n// 可以写成\nvar payload = { id }\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("属性名表达式")])]),t._v(" "),e("ul",[e("li",[t._v("ES6 允许字面量定义对象时，将表达式放在括号内。表达式还可以用于定义方法名：\n"),e("ul",[e("li",[t._v("注意，属性名表达式与简洁表示法，不能同时使用，会报错")]),t._v(" "),e("li",[t._v("注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]")])])])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("super关键字")])]),t._v(" "),e("ul",[e("li",[t._v("this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("扩展运算符的应用")])]),t._v(" "),e("ul",[e("li",[t._v("在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面：\n"),e("ul",[e("li",[t._v("注意：解构赋值必须是最后一个参数，否则会报错")]),t._v(" "),e("li",[t._v("解构赋值是浅拷贝。对象的扩展运算符等同于使用Object.assign()方法")])])])]),t._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[t._v("属性的遍历")])]),t._v(" "),e("ul",[e("li",[t._v("ES6 一共有 5 种方法可以遍历对象的属性：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）\nObject.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名\nObject.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名\nObject.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名\nReflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n")])])]),e("ul",[e("li",[t._v("上述遍历，都遵守同样的属性遍历的次序规则：\n"),e("ul",[e("li",[t._v("首先遍历所有数值键，按照数值升序排列")]),t._v(" "),e("li",[t._v("其次遍历所有字符串键，按照加入时间升序排列")]),t._v(" "),e("li",[t._v("最后遍历所有 Symbol 键，按照加入时间升序排")])])])]),t._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[t._v("对象新增的方法")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1、Object.is()：严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身\n\n2、Object.assign()：\n\nObject.assign()方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target\nObject.assign()方法的第一个参数是目标对象，后面的参数都是源对象\n注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换\n3、Object.getOwnPropertyDescriptors()：返回指定对象所有自身属性（非继承属性）的描述对象\n\n4、Object.setPrototypeOf()：用来设置一个对象的原型对象\n\n5、Object.getPrototypeOf()：用于读取一个对象的原型对象\n\n6、Object.keys()：返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组\n\n7、Object.values()：返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组\n\n8、Object.entries()：返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组\n\n9、Object.fromEntries()：用于将一个键值对数组转为对象\n")])])]),e("h2",{attrs:{id:"四、函数新增拓展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、函数新增拓展"}},[t._v("#")]),t._v(" 四、函数新增拓展")]),t._v(" "),e("ol",[e("li",[t._v("参数：es6允许函数的参数设置默认值，可以与解构赋值的默认值结合起来使用，当没有提供参数时避免报错；")]),t._v(" "),e("li",[t._v("属性\n"),e("ul",[e("li",[t._v("length\n"),e("ul",[e("li",[t._v("length将返回没有指定默认值的参数个数；")]),t._v(" "),e("li",[t._v("rest 参数也不会计入length属性；")])])]),t._v(" "),e("li",[t._v("name： 返回该函数的函数名\n"),e("ul",[e("li",[t._v("将一个具名函数赋值给一个变量，则name属性都返回这个具名函数原本的名字；")]),t._v(" "),e("li",[t._v("Function构造函数返回的函数实例，name属性的值为anonymous；")]),t._v(" "),e("li",[t._v("bind返回的函数，name属性值会加上bound前缀；")])])])])]),t._v(" "),e("li",[t._v("作用域：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域；等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的；")]),t._v(" "),e("li",[t._v("严格模式：只要使用了默认值、解构赋值、或者扩展运算符，函数内部都不能显示的设定为严格模式，否则会报错；")]),t._v(" "),e("li",[t._v("箭头函数；")])]),t._v(" "),e("h2",{attrs:{id:"五、set-和-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、set-和-map"}},[t._v("#")]),t._v(" 五、Set 和 Map")]),t._v(" "),e("p",[t._v("Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构。")]),t._v(" "),e("blockquote",[e("p",[t._v("集合：是由一堆无序的、相关联的，且不重复的内存结构（数学中称为元素）组成的组合。")]),t._v(" "),e("p",[t._v("字典：是一些元素的集合。每个元素都有一个称作key的域，不同元素的key各不相同。")])]),t._v(" "),e("p",[t._v("区别：")]),t._v(" "),e("ul",[e("li",[t._v("共同点：集合和字典都是可以存储不重复的值")]),t._v(" "),e("li",[t._v("不同点：集合以[值, 值]的形式存储，字典以[key, 值]的形式存储")])]),t._v(" "),e("h5",{attrs:{id:"set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" Set：")]),t._v(" "),e("p",[t._v("es6新增的数据结构，类似于数组，值唯一，无重复，我们一般称为集合。Set本身是一个构造函数，用于生成Set数据结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const s = new Set()\n\n[1,1,1,2,2,2,3,3,4,5,6,3,4,2,1].forEach(x => s.add(x))\n\nconsole.log(s) // Set(6) { 1, 2, 3, 4, 5, 6 }\n\nfor(let item of s){\n    console.log(item)\n}\n// 1 2 3 4 5 6\n")])])]),e("p",[t._v("以上代码使用add()向Set结构加入成员，表明Set结构不会添加重复的值")]),t._v(" "),e("p",[t._v("去除字符串中的重复字符")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[...new Set('aabbccabc')].join('') // \"abc\"\n")])])]),e("p",[t._v("属性：")]),t._v(" "),e("ul",[e("li",[t._v("Set.prototype.constructor: 构造函数，默认就是Set函数")]),t._v(" "),e("li",[t._v("Set.prototype.size: Set函数的成员总数")])]),t._v(" "),e("p",[t._v("操作方法：")]),t._v(" "),e("ul",[e("li",[t._v("add(value) 返回Set结构本身")]),t._v(" "),e("li",[t._v("delete(value) 返回一个Boolean，表示是否删除成功")]),t._v(" "),e("li",[t._v("has(value) 返回一个Boolean，表示是否包含")]),t._v(" "),e("li",[t._v("clear() 清除所有成员，没有返回")])]),t._v(" "),e("p",[t._v("遍历方法：")]),t._v(" "),e("ul",[e("li",[t._v("keys() 返回键名的遍历器")]),t._v(" "),e("li",[t._v("values() 返回键值的遍历器")]),t._v(" "),e("li",[t._v("entries() 返回键值对的遍历器")]),t._v(" "),e("li",[t._v("forEach() 使用回调函数遍历每个成员")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let set = new Set(['React', 'Vue', 'Angular'])\n\nfor(let item of set.keys()){\n    console.log(item) // React Vue Angular\n}\n\nfor(let item of set.values()){\n    console.log(item) // React Vue Angular\n}\n\nfor(let item of set.entries()){\n    console.log(item)\n}\n// [ 'React', 'React' ]\n// [ 'Vue', 'Vue' ]\n// [ 'Angular', 'Angular' ]\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let set = new Set([1, 4, 9]);\nset.forEach((key, value) => console.log(key+':'+value))\n// 1:1\n// 4:4\n// 9:9\n")])])]),e("h5",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" Map")]),t._v(" "),e("p",[t._v("Map类型是键值对的有序列表，而键和值都可以是任意类型，Map本身是一个构造函数，用来生成 Map 数据结构")]),t._v(" "),e("h2",{attrs:{id:"六、promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、promise"}},[t._v("#")]),t._v(" 六、Promise")]),t._v(" "),e("ol",[e("li")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[e("ul",[e("li")]),t._v(" "),e("blockquote")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li")]),t._v(" "),e("h2",{attrs:{id:"七、generator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、generator"}},[t._v("#")]),t._v(" 七、Generator")]),t._v(" "),e("ol",[e("li")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[e("ul",[e("li")]),t._v(" "),e("blockquote")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li")]),t._v(" "),e("h2",{attrs:{id:"八、proxy-用来自定义对象中的操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八、proxy-用来自定义对象中的操作"}},[t._v("#")]),t._v(" 八、Proxy(用来自定义对象中的操作)")]),t._v(" "),e("ol",[e("li")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[e("ul",[e("li")]),t._v(" "),e("blockquote")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li")]),t._v(" "),e("h2",{attrs:{id:"九、module"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#九、module"}},[t._v("#")]),t._v(" 九、Module")]),t._v(" "),e("ol",[e("li")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[e("ul",[e("li")]),t._v(" "),e("blockquote")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li")]),t._v(" "),e("h2",{attrs:{id:"十、decorator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十、decorator"}},[t._v("#")]),t._v(" 十、Decorator")]),t._v(" "),e("ol",[e("li")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[e("ul",[e("li")]),t._v(" "),e("blockquote")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li")]),t._v(" "),e("h2",{attrs:{id:"reflect是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reflect是什么"}},[t._v("#")]),t._v(" Reflect是什么")]),t._v(" "),e("p",[t._v("Reflect也是ES6新增的一个API，表示反射。它是一个对象，提供了很多操作对象的方法，类似于Object中的方法，比如 Reflect.getPrototypeOf 和 Object.getPrototypeOf。")]),t._v(" "),e("p",[t._v("早期操作对象的方法都是定义在Object上，但Object作为构造函数，直接放在它身上并不合适，所以新增Reflect对象来统一操作，并且转换了对象中in、delete这样的操作符")]),t._v(" "),e("comment-comment")],1)}),[],!1,null,null,null);e.default=r.exports}}]);