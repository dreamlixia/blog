(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{399:function(e,t,r){e.exports=r.p+"assets/img/数据双向绑定.bce02447.jpg"},432:function(e,t,r){"use strict";r.r(t);var s=r(56),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"双向数据绑定原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定原理"}},[e._v("#")]),e._v(" 双向数据绑定原理")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("Vue.js是采用数据劫持结合发布-订阅模式的方式，通过Object.defineProperty()来劫持各个属性的getter，setter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：")]),e._v(" "),s("ol",[s("li",[e._v("需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化")]),e._v(" "),s("li",[e._v("compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),s("li",[e._v("Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")]),e._v(" "),s("li",[e._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")])]),e._v(" "),s("div",{staticStyle:{"text-align":"center"}},[s("img",{attrs:{width:"100%",src:r(399),alt:""}})]),e._v(" "),s("comment-comment")],1)}),[],!1,null,null,null);t.default=i.exports}}]);