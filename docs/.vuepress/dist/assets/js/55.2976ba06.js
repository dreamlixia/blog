(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{586:function(t,a,s){"use strict";s.r(a);var e=s(76),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),s("p",[t._v("<浏览器执行顺序>")]),t._v(" "),s("h4",{attrs:{id:"浏览器事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器事件循环"}},[t._v("#")]),t._v(" 浏览器事件循环：")]),t._v(" "),s("p",[t._v("为了协调事件（event）、用户交互（user interaction）、脚本（script）、渲染（rendering）、网络（networking）等，用户代理（user agent）必须使用事件循环。")]),t._v(" "),s("h4",{attrs:{id:"nodejs事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs事件循环"}},[t._v("#")]),t._v(" nodejs事件循环：")]),t._v(" "),s("p",[t._v("事件循环允许Node.js执行非阻塞I/O操作，尽管JavaScript是单线程的，通过尽可能将操作卸载到系统内核。\n由于大多数现代内核都是多线程的，因此他们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便可以将相应回调添加到轮询队列中最终执行。")]),t._v(" "),s("h4",{attrs:{id:"事件循环本质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环本质"}},[t._v("#")]),t._v(" 事件循环本质：")]),t._v(" "),s("p",[t._v("在浏览器或者nodejs环境中，运行时对js脚本的调度方式叫做事件循环。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("setTimeout(() => {\n    console.log('setTimeout')\n}, 0)\n\nPromise.resolve().then(() => {\n    console.log('promise')\n})\n\nconsole.log('main')\n\n// main\n// promise\n// setTimeout\n")])])]),s("p",[t._v("事件循环：由于js是单线程的，一次只能执行一个任务。那么多个任务堆在一起时，就要这些任务排排队。按照先进先出的规则，形成一条消息队列。")]),t._v(" "),s("p",[t._v("多个任务源，形成多条消息队列")]),t._v(" "),s("p",[t._v("这就形成一条事件循环的执行队列。")]),t._v(" "),s("p",[t._v("事件循环：就是一个执行消息队列的机制。")]),t._v(" "),s("p",[t._v("为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）。")]),t._v(" "),s("h4",{attrs:{id:"event-loop事件循环-是js或node为解决单线程代码执行不阻塞主进程的一种机制-也就是我们所说的异步原理。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop事件循环-是js或node为解决单线程代码执行不阻塞主进程的一种机制-也就是我们所说的异步原理。"}},[t._v("#")]),t._v(" Event Loop事件循环，是js或node为解决单线程代码执行不阻塞主进程的一种机制，也就是我们所说的异步原理。")]),t._v(" "),s("h4",{attrs:{id:"事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。"}},[t._v("#")]),t._v(" 事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。")]),t._v(" "),s("h2",{attrs:{id:"进程和线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[t._v("#")]),t._v(" 进程和线程")]),t._v(" "),s("p",[t._v("进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。")]),t._v(" "),s("p",[t._v("线程（thread）是操作系统能够进行运算调度的最小单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。")]),t._v(" "),s("h2",{attrs:{id:"宏任务和微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),s("p",[t._v("宏任务：当前调用栈中执行的代码称为宏任务。（主代码块，定时器等等）。")]),t._v(" "),s("p",[t._v("微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。")]),t._v(" "),s("p",[t._v("宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。")]),t._v(" "),s("p",[t._v("微任务：process.nextTick、MutationObserver、Promise.then catch finally")]),t._v(" "),s("p",[t._v("宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame、ajax、事件绑定")]),t._v(" "),s("h2",{attrs:{id:"单线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[t._v("#")]),t._v(" 单线程")]),t._v(" "),s("p",[t._v("在程序执行时，前一个任务执行完成后才能执行下一个任务（阻塞：等待）。")]),t._v(" "),s("h2",{attrs:{id:"javascript为什么是单线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript为什么是单线程"}},[t._v("#")]),t._v(" JavaScript为什么是单线程")]),t._v(" "),s("p",[t._v("跟他的用途有关，作为浏览器脚本语言，js的主要用途就是与用户互动，以及操作Dom，这决定了它只能是单线程，否则会带来复杂的同步问题。假定js同时有两个线程，一个线程给在某个dom节点上添加内容，另一个线程删除了这个节点，这时浏览器该以哪个线程为准？")]),t._v(" "),s("p",[t._v("所以为了避免复杂性，从一诞生，js就是单线程，这已经成了这门语言的核心特征，将来也不会改变。")]),t._v(" "),s("h2",{attrs:{id:"javascript如何解决单线程阻塞的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript如何解决单线程阻塞的问题"}},[t._v("#")]),t._v(" JavaScript如何解决单线程阻塞的问题")]),t._v(" "),s("p",[t._v("因为阻塞导致的任务等待，比如ajax请求要等着返回结果，再往下执行。所以js语言设计的任务可以分为两种：同步任务和异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程，而进入‘任务队列(task queue)’的任务，只有‘任务队列’通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。")]),t._v(" "),s("h2",{attrs:{id:"javascript运行机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript运行机制"}},[t._v("#")]),t._v(" JavaScript运行机制")]),t._v(" "),s("ul",[s("li",[t._v("整体的sript开始执行的时候，会把所有代码分为同步任务、异步任务；")]),t._v(" "),s("li",[t._v("同步任务会直接进入主线程依次执行；")]),t._v(" "),s("li",[t._v("异步任务会分为宏任务（进入宏任务队列）和微任务（进入微任务队列）；")]),t._v(" "),s("li",[t._v("当主线程内的任务执行完成，会检查微任务队列，如果有任务，就进入主线程全部执行，如果没有就从宏任务队列读取下一个宏任务执行；")]),t._v(" "),s("li",[t._v("每执行完一个宏任务就清空一次微任务队列，此过程会不断重复，这就是Event Loop。")])]),t._v(" "),s("comment-comment")],1)}),[],!1,null,null,null);a.default=r.exports}}]);