(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{456:function(e,n,t){"use strict";t.r(n);var s=t(27),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"介绍-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍-promise"}},[e._v("#")]),e._v(" --- 介绍 Promise ---")]),e._v(" "),t("h2",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),t("ol",[t("li",[e._v("Promise 是异步编程的一种解决方案，比传统的回调和事件更合理，由社区提出和实现经由 ES6 写进语言标准，并在原生提供了 Promise 对象。")]),e._v(" "),t("li",[e._v("Promise 可以理解为一个容器，里面保存着某个将来才会结束的事件（异步操作）的结果。从语法上来说，Promise 是一个对象，通过它可以获取到异步操作的消息，Promise 提供了统一的API，各种异步操作都可以进行同样的处理。")])]),e._v(" "),t("h2",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[e._v("#")]),e._v(" 特点")]),e._v(" "),t("ol",[t("li",[e._v("Promise 对象代表一个异步操作，对象的状态不受外界影响，有三种状态，pending（进行中）， fulfilled（已完成）， rejected（已失败）；只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态。")]),e._v(" "),t("li",[e._v("状态一旦更改就不会再变，Promise 对象的状态改变，只有两种可能，从 pending 变为 fulfilled， 从 pending 变为 rejected，如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是，只要你错过了它，再去监听是得不到结果的。")]),e._v(" "),t("li",[e._v("构造函数 Promise 必须接收一个函数（handle）作为参数，函数包含 resolve 和 rejected。")]),e._v(" "),t("li",[e._v(".then 和 .catch 支持链式调用。")])]),e._v(" "),t("h2",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),t("ol",[t("li",[e._v("Promise 一旦新建就会执行， 中途无法取消。")]),e._v(" "),t("li",[e._v("如果不设置回调函数，Promise 内部抛出的错误无法反映到外部。")]),e._v(" "),t("li",[e._v("当处于 pending 状态时，无法知道目前进展到哪一阶段。")])]),e._v(" "),t("h2",{attrs:{id:"场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[e._v("#")]),e._v(" 场景")]),e._v(" "),t("ol",[t("li",[e._v("有效解决 js 异步回调地狱问题；")]),e._v(" "),t("li",[e._v("将业务逻辑和数据处理分隔开使代码更优雅，方便阅读，有利于维护。")])]),e._v(" "),t("h2",{attrs:{id:"描述-promise-的底层实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#描述-promise-的底层实现"}},[e._v("#")]),e._v(" --- 描述 Promise 的底层实现 ---")]),e._v(" "),t("h2",{attrs:{id:"基础版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础版本"}},[e._v("#")]),e._v(" 基础版本")]),e._v(" "),t("p",[e._v("设定三个状态 PENDING、FULFILLED、REJECTED, 只能由 PENDING 改为 FULFILLED、REJECTED, 并且只能改变一次")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(executor) {\n    this.state = PENDING;\n    this.value = null;\n    this.reason = null;\n\n    const resolve = (value) => {\n        if(this.state == PENDING) {\n            this.state = FULFILLED;\n            this.value = value;\n        }\n    }\n\n    const reject = (reason) => {\n        if(this.state == PENDING) {\n            this.state = REJECTED;\n            this.reason = reason;\n        }\n    }\n\n    try{\n        executor(resolve, reject);\n    } catch (reason) {\n        reject(reason);\n    }\n}\n")])])]),t("h2",{attrs:{id:"then方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then方法"}},[e._v("#")]),e._v(" then方法")]),e._v(" "),t("ul",[t("li",[e._v("then方法接受两个参数，onFulfilled、onRejected, 他们分别在 PENDING 改变为 FULFILLED 、REJECTED 后调用。")]),e._v(" "),t("li",[e._v("一个 primose 可绑定多个 then 方法")]),e._v(" "),t("li",[e._v("then方法可以同步调用也可以异步调用")]),e._v(" "),t("li",[e._v("同步调用：状态已经改变，直接调用 onFulfilled 方法")]),e._v(" "),t("li",[e._v("异步调用：状态还是PENDING，将 onFulfilled、onRejected 分别加入两个函数数组 onFulfilledCallbacks、onRejectedCallbacks ，当异步调用 resolve 和 reject 时，将两个数组中绑定的事件循环执行。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(executor) {\n    this.state = PENDING;\n    this.value = null;\n    this.reason = null;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    const resolve = (value) => {\n        if(this.state == PENDING) {\n            this.state = FULFILLED;\n            this.value = value;\n            this.onFulfilledCallbacks.forEach(fun => {\n                fun();\n            })\n        }\n    }\n\n    const reject = (reason) => {\n        if(this.state == PENDING) {\n            this.state = REJECTED;\n            this.reason = reason;\n            this.onRejectedCallbacks.forEach(fun => {\n                fun();\n            })\n        }\n    }\n\n    try{\n        executor(resolve, reject);\n    } catch (reason) {\n        reject(reason);\n    }\n}\n\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n    switch(this.state) {\n        case FULFILLED:\n            onRejected(this.value);\n            break;\n        case REJECTED:\n            onFulfilled(this.value);\n            break;\n        case PENDING:\n            this.onFulfilledCallbacks.push(() => {\n                onFulfilled(this.value);\n            })\n            this.onRejectedCallbacks.push(() => {\n                onRejected(this.reason);\n            })\n            break;\n    }\n}\n")])])]),t("h2",{attrs:{id:"then方法异步调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then方法异步调用"}},[e._v("#")]),e._v(" then方法异步调用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(1)\n\nlet promise = new Promise((resolve, reject) => {\n    resolve('resolve')\n})\n\npromise.then(value => {\n    console.log(value)\n})\n\nconsole.log(2)\n// 1\n// 2\n// resolve\n")])])]),t("p",[e._v("虽然resolve是同步执行的，我们必须保证then是异步调用的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.then = function(onFulfilled, onRejected) {\n    if(typeof onFulfilled != 'function') {\n        onFulfilled = function (value) {\n            return value;\n        }\n    }\n    if(typeof onRejected != 'function') {\n        onRejected = function(reason) {\n            return reason;\n        }\n    }\n    switch(this.state) {\n        case FULFILLED:\n            setTimeout(() => {\n                onFulfilled(this.value);\n            }, 0);\n            break;\n        case REJECTED:\n            setTimeout(() => {\n                onRejected(this.reason);\n            }, 0)\n            break;\n        case PENDING:\n            this.onFulfilledCallbacks.push(() => {\n                setTimeout(() => {\n                    onFulfilled(this.value)\n                }, 0)\n            })\n            this.onRejectedCallbacks.push(() => {\n                setTimeout(() => {\n                    onRejected(this.reason)\n                }, 0)\n            })\n            break;\n    }\n}\n")])])]),t("h2",{attrs:{id:"then方法链式调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then方法链式调用"}},[e._v("#")]),e._v(" then方法链式调用")]),e._v(" "),t("p",[e._v("保证链式调用，即 then 方法中要返回一个新的promise，并将 then 方法的返回值进行 resolve 。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.then = function(onFulfilled, onRejected) {\n    if(typeof onFulfilled != 'function') {\n        onFulfilled = function(value) {\n            return value;\n        }\n    }\n    if(typeof onRejected != 'function') {\n        onRejected = function(reason) {\n            return reason;\n        }\n    }\n    const promise2 = new MyPromise((resolve, reject) => {\n        switch(this.state) {\n            case FULFILLED: \n                setTimeout(() => {\n                    try {\n                        const x = onFulfilled(this.value);\n                        resolve(x)\n                    } catch(reason) {\n                        reject(reason)\n                    }\n                }, 0)\n                break;\n            case REJECTED: \n                setTimeout(() => {\n                    try {\n                        const x = onRejected(this.reason);\n                        resolve(x)\n                    } catch(reason) {\n                        reject(reason)\n                    }\n                }, 0)\n                break;\n            case PENDING: \n                this.onFulfilledCallbacks.push(() => {\n                    setTimeout(() => {\n                        try {\n                            const x = onFulfilled(this.value)\n                            resolve(x)\n                        } catch(reason) {\n                            reject(reason)\n                        }\n                    }, 0)\n                })\n                this.onRejectedCallbacks.push(() => {\n                    setTimeout(() => {\n                        try {\n                            const x = onRejected(this.reason)\n                            resolve(x)\n                        } catch(reason) {\n                            reject(reason)\n                        }\n                    }, 0)\n                })\n                break;\n        }\n    })\n    return promise2;\n})\n")])])]),t("h2",{attrs:{id:"catch-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#catch-方法"}},[e._v("#")]),e._v(" catch 方法")]),e._v(" "),t("p",[e._v("若上面没有定义 reject 方法，所有的异常都会走向 catch 方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected);\n}\n")])])]),t("h2",{attrs:{id:"finally-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finally-方法"}},[e._v("#")]),e._v(" finally 方法")]),e._v(" "),t("p",[e._v("不管是 resolve 还是 reject 都会调用 finally")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.prototype.finally = function(fn) {\n    return this.then(value => {\n        fn();\n        return value;\n    }, reason => {\n        fn();\n        throw reason;\n    })\n}\n")])])]),t("h2",{attrs:{id:"promise-resolve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" Promise.resolve")]),e._v(" "),t("p",[e._v("用来生成一个直接处于 FULFILLED 状态的Promise.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.resolve = function(value) {\n    return new myPromise((resolve, reject) => {\n        resolve(value);\n    })\n}\n")])])]),t("h2",{attrs:{id:"promise-reject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject")]),e._v(" "),t("p",[e._v("用来生成一个直接处于 REJECTED 状态的Promise.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.reject = function(reason) {\n    return new myPromise((resolve, reject) => {\n        reject(reason);\n    })\n}\n")])])]),t("h2",{attrs:{id:"all方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#all方法"}},[e._v("#")]),e._v(" all方法")]),e._v(" "),t("p",[e._v("接受一个 promise 数组，当所有 promise 状态 resolve 后，执行 resolve.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.all = function(promises) {\n    return new Promise((resolve, reject) => {\n        if(promises.length === 0) {\n            resolve([]);\n        } else {\n            let result = [];\n            let index = 0;\n            for(let i = 0; i < promises.length; i ++) {\n                promises[i].then(data => {\n                    result[i] = data;\n                    if(++index == promises.length) {\n                        resolve(result);\n                    }\n                }, err => {\n                    reject(err);\n                    return;\n                })\n            }\n        }\n    })\n}\n")])])]),t("h2",{attrs:{id:"race-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#race-方法"}},[e._v("#")]),e._v(" race 方法")]),e._v(" "),t("p",[e._v("接受一个 promise 数组，当有一个 promise 状态 resolve 后，执行 resolve.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPromise.race = function(promisess) {\n    return new Promise((resolve, reject) => {\n        if(promises.length === 0) {\n            resolve();\n        } else {\n            let index = 0;\n            for(let i = 0; i < promises.length; i ++) {\n                promises[i].then(data => {\n                    resolve(data);\n                }, err => {\n                    reject(err);\n                    return;\n                })\n            }\n        }\n    })\n}\n")])])]),e._v(" "),t("comment-comment")],1)}),[],!1,null,null,null);n.default=a.exports}}]);