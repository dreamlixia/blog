(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{473:function(t,e,a){"use strict";a.r(e);var s=a(27),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"solid五大设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#solid五大设计原则"}},[t._v("#")]),t._v(" solid五大设计原则")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"单一职责原则-the-single-responsibility-principle-srp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则-the-single-responsibility-principle-srp"}},[t._v("#")]),t._v(" 单一职责原则 The Single-Responsibility Principle (SRP)")]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"单一职责原则-就是说一个类仅有一个引起它变化的原因。也有人把它解释为只做一件事情"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则-就是说一个类仅有一个引起它变化的原因。也有人把它解释为只做一件事情"}},[t._v("#")]),t._v(" 单一职责原则，就是说一个类仅有一个引起它变化的原因。也有人把它解释为只做一件事情")])]),t._v(" "),a("h4",{attrs:{id:"开放闭合原则-the-open-closed-principle-ocp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开放闭合原则-the-open-closed-principle-ocp"}},[t._v("#")]),t._v(" 开放闭合原则 The Open/Closed Principle (OCP)")]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"所有的系统在其生命周期里都会改变-需求会变是正常的-好的系统不会拒绝变化-只会需要添加code或者修改很少的code就能支持这些变化。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有的系统在其生命周期里都会改变-需求会变是正常的-好的系统不会拒绝变化-只会需要添加code或者修改很少的code就能支持这些变化。"}},[t._v("#")]),t._v(" 所有的系统在其生命周期里都会改变，需求会变是正常的，好的系统不会拒绝变化，只会需要添加code或者修改很少的code就能支持这些变化。")]),t._v(" "),a("h5",{attrs:{id:"它强调对扩展开放-对修改闭合。办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#它强调对扩展开放-对修改闭合。办法"}},[t._v("#")]),t._v(" 它强调对扩展开放，对修改闭合。办法：")]),t._v(" "),a("h5",{attrs:{id:"抽象、多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象、多态"}},[t._v("#")]),t._v(" 抽象、多态")])]),t._v(" "),a("h4",{attrs:{id:"里氏替换原则-the-liskov-substitution-principle-lsp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则-the-liskov-substitution-principle-lsp"}},[t._v("#")]),t._v(" 里氏替换原则 The Liskov Substitution Principle (LSP)")]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"自类型必须能够替换它的基类型。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自类型必须能够替换它的基类型。"}},[t._v("#")]),t._v(" 自类型必须能够替换它的基类型。")]),t._v(" "),a("h5",{attrs:{id:"强调继承。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强调继承。"}},[t._v("#")]),t._v(" 强调继承。")]),t._v(" "),a("h5",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h5",{attrs:{id:"-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[t._v("#")])])]),t._v(" "),a("h4",{attrs:{id:"接口分离原则-the-interface-segregation-principle-isp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口分离原则-the-interface-segregation-principle-isp"}},[t._v("#")]),t._v(" 接口分离原则 The Interface Segregation Principle (ISP)")]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"客户端不应该被迫依赖于它不使用的方法。简单来说就是更小更具体的瘦接口比庞大臃肿的胖接口好。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端不应该被迫依赖于它不使用的方法。简单来说就是更小更具体的瘦接口比庞大臃肿的胖接口好。"}},[t._v("#")]),t._v(" 客户端不应该被迫依赖于它不使用的方法。简单来说就是更小更具体的瘦接口比庞大臃肿的胖接口好。")])]),t._v(" "),a("h4",{attrs:{id:"依赖倒置原则-the-dependency-inversion-principle-dip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则-the-dependency-inversion-principle-dip"}},[t._v("#")]),t._v(" 依赖倒置原则 The Dependency-Inversion Principle (DIP)")]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"高层模块不应该依赖低层模块-两者都应该依赖其抽象。抽象不应该依赖细节-细节应该依赖于抽象。低层模块不应该影响高层模块-否则高层模块很难做到复用。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高层模块不应该依赖低层模块-两者都应该依赖其抽象。抽象不应该依赖细节-细节应该依赖于抽象。低层模块不应该影响高层模块-否则高层模块很难做到复用。"}},[t._v("#")]),t._v(" 高层模块不应该依赖低层模块，两者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖于抽象。低层模块不应该影响高层模块，否则高层模块很难做到复用。")])]),t._v(" "),a("comment-comment")],1)}),[],!1,null,null,null);e.default=r.exports}}]);