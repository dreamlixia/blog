(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{464:function(e,a,t){"use strict";t.r(a);var s=t(27),v=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"对keep-alive的理解-如何实现-具体缓存的是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对keep-alive的理解-如何实现-具体缓存的是什么"}},[e._v("#")]),e._v(" 对keep-alive的理解，如何实现，具体缓存的是什么")]),e._v(" "),t("h2",{attrs:{id:"_1-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[e._v("#")]),e._v(" 1.概念")]),e._v(" "),t("p",[e._v("如果需要在组件切换的时候，保留一些组件的状态防止多次渲染，就需要使用<keep-alive>包裹需要保存的组件。")]),e._v(" "),t("p",[e._v("用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<keep-alive> // 基本\n    <component :is="view"></component>\n</keep-alive>\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<keep-alive> // 多个条件判断的子组件\n    <compo-a v-if="a > 1"></compo-a>\n    <compo-b v-else></compo-b>\n</keep-alive>\n')])])]),t("h2",{attrs:{id:"_2-props"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-props"}},[e._v("#")]),e._v(" 2.Props")]),e._v(" "),t("ul",[t("li",[e._v("includes: 只能缓存名称匹配的组件")]),e._v(" "),t("li",[e._v("exculdes: 任何名称匹配的组件都不会被缓存")]),e._v(" "),t("li",[e._v("max: 最多可以缓存组件实例的个数")])]),e._v(" "),t("p",[e._v("<keep-alive>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。")]),e._v(" "),t("p",[e._v("当组件在<keep-alive>内被切换时，生命周期 activated 和 deactivated 会被调用。")]),e._v(" "),t("h2",{attrs:{id:"_3-render函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-render函数"}},[e._v("#")]),e._v(" 3.render函数")]),e._v(" "),t("ul",[t("li",[e._v("会在<keep-alive>组件内部去写自己的内容，所以可以获取slot的内容，然后根据这个去获取组件")]),e._v(" "),t("li",[e._v("<keep-alive>只对第一个组件有效，所以只获取第一个子组件")]),e._v(" "),t("li",[e._v("和<keep-alive>搭配使用的一般有：动态组件和router-view")])]),e._v(" "),t("p",[e._v("内容待更新……")]),e._v(" "),t("h2",{attrs:{id:"lru-least-recently-used-缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru-least-recently-used-缓存策略"}},[e._v("#")]),e._v(" LRU （least recently used）缓存策略")]),e._v(" "),t("p",[e._v('LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。\nLRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 "如果数据最近被访问过，那么将来被访问的几率也更高"。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶')]),e._v(" "),t("ul",[t("li",[e._v("新数据插入到链表头部")]),e._v(" "),t("li",[e._v("每当缓存命中（即缓存数据被访问），则将数据移到链表头部")]),e._v(" "),t("li",[e._v("链表满的时候，将链表尾部的数据丢弃。")])]),e._v(" "),t("comment-comment")],1)}),[],!1,null,null,null);a.default=v.exports}}]);