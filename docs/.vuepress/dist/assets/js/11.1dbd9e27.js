(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{412:function(e,t,s){e.exports=s.p+"assets/img/hooks1.f00b4245.jpg"},460:function(e,t,s){"use strict";s.r(t);var n=s(27),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"react-hooks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[e._v("#")]),e._v(" React-Hooks:")]),e._v(" "),n("p",[e._v("是函数组件解决没有state，生命周期，逻辑不能复用的一种技术方案。")]),e._v(" "),n("p",[e._v("Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")]),e._v(" "),n("h2",{attrs:{id:"function和class组件本质的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function和class组件本质的区别"}},[e._v("#")]),e._v(" function和class组件本质的区别：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Index extends Component<any,any>{\n    constructor(props){\n        super(props)\n        this.state = {\n            num: 0\n        }\n    }\n    handleClick = () => {\n        for(let i=0; i< 5; i++ ){\n            setTimeout(()=>{\n                this.setState({number: this.state.num+1})\n                console.log(this.state.num)\n            }, 1000)\n        }\n    }\n    render() {\n        return <div>\n            <div onClick={this.handleClick}>num++</div>\n        </div>\n    }\n}\nexport default Index;\n")])])]),n("p",[e._v("打印结果： 1 2 3 4 5")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Index () {\n    const [num, setNumber] = React.useState(0)\n    const handleClick = () => {\n        for(let i=0; i<5; i++){\n            setTimeout(()=>{\n                setNumber(num+1)\n                console.log(num)\n            }, 1000)\n        }\n    }\n    return <div onClick={handleClick}>{num}</div>\n}\n")])])]),n("p",[e._v("打印结果：0 0 0 0 0")]),e._v(" "),n("p",[n("strong",[e._v("对于class组件，只需要实例化一次，实例中保存了state等状态，每次更新只需要调用render方法即可。但是在function组件中，每一次更新都是一次新的函数执行，为了保存一些状态，执行一些副作用钩子，react-hooks应运而生，去帮助组件记录一些状态，处理一些额外的副作用。")])]),e._v(" "),n("h2",{attrs:{id:"hooks初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hooks初始化"}},[e._v("#")]),e._v(" Hooks初始化：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("useState  // 负责组件更新\nuseEffect // 执行副作用\nuseRef    // 保存数据\nuseMemo   // 缓存优化\n\nuseCallback\nuseReducer\nuseLayoutEffect\n")])])]),n("p",[e._v("示例代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect, useMemo, useRef } from 'react';\n\nfunction Index() {\n    const [number, setNumber] = useState(0);\n    const divDemo = useMemo(() => <div>hello, I am a divDemo.</div>, [])\n    const curRef = useRef(null);\n    useEffect(()=>{\n        console.log(curRef.current)\n    },[])\n    return <div ref={ curRef }>\n        hello world { number }\n        { divDemo }\n        <button onClick={() => setNumber(number+1)}>number ++</button>\n    </div>\n}\n")])])]),n("ol",[n("li",[n("strong",[e._v("mountWorkInProgressHook")])])]),e._v(" "),n("p",[e._v("在组件初始化的时候，每一次hooks执行，如useState(), useEffect(), 都会调用mountWorkInProgressHook.")]),e._v(" "),n("p",[e._v("mountWorkInProgressHook做的事情：首先每次执行一个hooks函数，都产生一个hooks对象，里面保存了当前hook信息，然后将每个hooks以链表形式串联起来，并赋值给workInProgress的memoizedState。也就证明了函数组件用memoizedState存放hooks链表。")]),e._v(" "),n("ul",[n("li",[e._v("memoizedState:\n"),n("ul",[n("li",[e._v("useState：保存state信息")]),e._v(" "),n("li",[e._v("useEffect：保存effect对象")]),e._v(" "),n("li",[e._v("useRef：保存ref对象")]),e._v(" "),n("li",[e._v("useMemo：保存缓存的值和deps")])])]),e._v(" "),n("li",[e._v("baseQueue: useState和useEffect中保存最新的更新队列。")]),e._v(" "),n("li",[e._v("baseState: useState和useEffect中，一次更新中，产生的最新的state值。")]),e._v(" "),n("li",[e._v("queue: 保存待更新队列pendingQueue，更新函数dispatch等信息。")]),e._v(" "),n("li",[e._v("next: 指向下一个hooks对象。\n"),n("div",{staticStyle:{"text-align":"center"}},[n("img",{attrs:{width:"100%",src:s(412),alt:""}})])])]),e._v(" "),n("p",[n("strong",[e._v("不能在条件语句中声明hooks:")]),e._v(" 因为一旦在条件语句中声明hooks，在下一次函数组件更新，hooks链表结构，将会被破坏，current树的memoizedState缓存hooks信息，和当前workInProgress不一致，如果涉及到读取state等操作，就会发生异常。")]),e._v(" "),n("p",[n("font",{attrs:{color:"#dd0000"}},[e._v("🌟总结：hooks是通过什么证明唯一性的？答：通过hooks链表顺序。")])],1),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("strong",[e._v("useState => mountState")])])]),e._v(" "),n("p",[e._v("在无状态组件中，useState和useReducer触发函数更新的方法都是dispatchAction，useState可以看成是一个简版的useReducer。")]),e._v(" "),n("p",[e._v("dispatchAction无状态组件更新机制: dispatchAction就是setNumber。")]),e._v(" "),n("ul",[n("li",[e._v("无论是类组件调用setState，还是函数组件的dispatchAction，都会产生一个update对象，里面记录了此次更新的信息，然后将此update放入待更新的pending队列中。dispatchAction的第二步就是判断当前函数组件的fiber对象是否处于渲染阶段。如果处于渲染阶段，那么不需要我们更新当前函数组件，只需要更新当前的update和expirationTime即可。")]),e._v(" "),n("li",[e._v("如果当前fiber没有处于更新阶段，那么通过调用lastRenderedReducer获取最新state，和上一次的currentState进行浅比较，如果相等，就退出。证实了useState两次值相等的时候组件就不进行渲染了，这和Component模式下的setState有一定的区别。")]),e._v(" "),n("li",[e._v("如果两次state不相等，调用scheduleUpdateOnFiber调度渲染当前fiber，"),n("font",{attrs:{color:"#dd0000"}},[e._v("scheduleUpdateOnFiber")]),e._v("是react渲染更新的主要函数。")],1)]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("strong",[e._v("useEffect => mountEffect")])])]),e._v(" "),n("p",[e._v("每个hooks初始化都会创建一个hook对象，然后将hook的memoizedState保存当前的effect hook信息。")]),e._v(" "),n("p",[e._v("有两个memoizedState不要混淆")]),e._v(" "),n("ul",[n("li",[e._v("workInProgress / current 树上的memoizedState保存的是当前函数组件每个hooks形成的链表。")]),e._v(" "),n("li",[e._v("每个hooks上的memoizedState保存的是当前hooks的信息，不同种类的hooks的memoizedState内容不同。")])]),e._v(" "),n("p",[e._v("pushEffect")]),e._v(" "),n("comment-comment")],1)}),[],!1,null,null,null);t.default=o.exports}}]);