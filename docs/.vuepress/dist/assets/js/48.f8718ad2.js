(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{576:function(n,t,a){"use strict";a.r(t);var e=a(76),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[n._v("#")]),n._v(" 区别")]),n._v(" "),a("ul",[a("li",[n._v("都用来改变 this 指向；")]),n._v(" "),a("li",[n._v("call 、apply 在改变 this 指向的同时会执行函数，一次性的。不同的是 call 方法传递函数调用的形参是散列的形式，apply 的行参是一个数组。在传参的情况下，call 的性能要高于 apply， 因为 apply 还需要解析数组。")]),n._v(" "),a("li",[n._v("bind 在改变 this 指向后是返回一个全新的绑定函数，不直接执行函数。"),a("strong",[n._v("一个函数被 bind 绑定后，那么这个返回的新函数无法再通过 call 、 apply 改变 this 指向。")])])]),n._v(" "),a("h2",{attrs:{id:"用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[n._v("#")]),n._v(" 用法")]),n._v(" "),a("h3",{attrs:{id:"call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[n._v("#")]),n._v(" call")]),n._v(" "),a("ul",[a("li",[n._v("call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。")])]),n._v(" "),a("blockquote",[a("p",[n._v("function.call(thisArg, arg1, arg2, ...);")]),n._v(" "),a("p",[n._v("[thisArg] 必填， [arg1, arg2, ...] 可选；")]),n._v(" "),a("p",[n._v("在 function 函数运行时使用的 this 值，指定为 null 或 undefined 时，this 自动替换为指向全局对象。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let callObj = {\n    name: '我是call'\n}\nfunction fn() {\n    console.log('参数 =>', ...arguments);\n    console.log('name =>', this.name);\n}\nfn.call(callObj, 1, 2, 3)\n// 参数 => 1 2 3\n// name => 我是call\n")])])]),a("h3",{attrs:{id:"apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[n._v("#")]),n._v(" apply")]),n._v(" "),a("ul",[a("li",[n._v("方法调用一个具有给定 this 值的函数，以及以一个数组（或类数组对象）的形式提供参数。")])]),n._v(" "),a("blockquote",[a("p",[n._v("function.apply(thisArg, [argsArray]);")]),n._v(" "),a("p",[n._v("[thisArg] 必填；[argsArray] 可选；")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let objApply = {\n    name: '我是apply'\n}\nfunction fn() {\n    console.log('参数 =>', ...arguments);\n    console.log('name =>', this.name);\n}\nfn.apply(objApply, [1, 2, 3]);\n// 参数 => 1 2 3\n// name => 我是apply\n")])])]),a("h3",{attrs:{id:"bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[n._v("#")]),n._v(" bind")]),n._v(" "),a("ul",[a("li",[n._v("方法创建一个新的函数，在 bind() 被调用时，这个新的函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。")])]),n._v(" "),a("blockquote",[a("p",[n._v("function.bind(thisArg, [, arg1[, arg2[, arg3[, ...]]]])")]),n._v(" "),a("p",[n._v("[thisArg]")]),n._v(" "),a("p",[n._v("[arg1, arg2, arg3, ...] 当目标函数被调用时，被预置入绑定函数参数列表中的参数。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let objBind = {\n    name: '我是bind'\n}\nlet objApply = {\n    name: '我是apply'\n}\nlet callObj = {\n    name: '我是call'\n}\nfunction fn() {\n    console.log('参数 =>', ...arguments);\n    console.log('name =>', this.name);\n}\nlet bfn = fn.bind(objBind, 1, 2, 3); // 或 fn.bind(objBind)(1, 2, 3);\nbfn();\n// 参数 => 1 2 3\n// name => 我是bind\n\nbfn.call(objCall);\nbfn.apply(objApply);\n// 参数 => 1 2 3\n// name => 我是bind // 无法再改变\n// 参数 => 1 2 3\n// name => 我是bind\n")])])]),a("h2",{attrs:{id:"手写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写"}},[n._v("#")]),n._v(" 手写")]),n._v(" "),a("h3",{attrs:{id:"模拟实现-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模拟实现-call"}},[n._v("#")]),n._v(" 模拟实现 call")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Function.prototype.myCall = function(context = window, ...args) {\n    if(this === Function.prototype) {\n        return undefined; // 防止直接调用\n    }\n    context = context || window;\n    const fn = Symbol();\n    context[fn] = this;\n    const result = context[fn](...args);\n    delete context[fn];\n    return result;\n}\n")])])]),a("h3",{attrs:{id:"模拟实现-apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模拟实现-apply"}},[n._v("#")]),n._v(" 模拟实现 apply")]),n._v(" "),a("p",[n._v("apply 和 call 类似，参数为数组")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Function.prototype.myApply = function(context = window, args) {\n    if(this === Function.prototype) {\n        return undefined;\n    }\n    // context = context || window;\n    const fn = Symbol();\n    context[fn] = this;\n    let result;\n    if(Array.isArray(args)) {\n        result = context[fn](...args);\n    } else {\n        result = context[fn]();\n    }\n    delete context[fn];\n    return result;\n}\n")])])]),a("h3",{attrs:{id:"模拟实现-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模拟实现-bind"}},[n._v("#")]),n._v(" 模拟实现 bind")]),n._v(" "),a("ol",[a("li",[n._v("处理参数，返回一个闭包")]),n._v(" "),a("li",[n._v("判断是否为构造函数调用，如果是则使用new调用当前函数")]),n._v(" "),a("li",[n._v("如果不是，使用apply，将context和处理好的参数传入")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    Function.prototype.myBind = function (context,...args1) {\n      if (this === Function.prototype) {\n        throw new TypeError('Error')\n      }\n      const _this = this\n      return function F(...args2) {\n        // 判断是否用于构造函数\n        if (this instanceof F) {\n          return new _this(...args1, ...args2)\n        }\n        return _this.apply(context, args1.concat(args2))\n      }\n    }\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Function.prototype.mybind = function () {\n  if (typeof this !== 'function') throw 'Bind must be called on a function'\n  let _this = this, //这里的this是原函数\n    context = arguments[0],//获取要this指向的对象\n    slice = Array.prototype.slice,\n    args = slice.call(arguments, 1);//获取bind函数除this指向对象外的所有参数\n  //返回函数    \n  return function () {\n    args = args.concat(slice.call(arguments))//合并bind的入参和执行时的入参\n    return _this.apply(context, args)\n  }\n}\n")])])]),n._v(" "),a("comment-comment")],1)}),[],!1,null,null,null);t.default=s.exports}}]);