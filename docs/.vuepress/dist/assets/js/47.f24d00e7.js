(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{464:function(e,s,t){"use strict";t.r(s);var a=t(27),r=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"fetch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fetch"}},[e._v("#")]),e._v(" Fetch")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("fetch的功能与XMLHttpRequest基本相同，但只要有三个差异。")]),e._v(" "),t("p",[e._v("（1）fetch使用Promise，不使用回调函数，因此大大简化了写法，更简洁。")]),e._v(" "),t("p",[e._v("（2）fetch采用模块化设计，api分散在多个对象上（request对象、response对象、headers对象），更合理。相比XMLHttpRequest的api设计，输入、输出、状态都在同一个接口管理，容易写出混乱的代码。")]),e._v(" "),t("p",[e._v("（3）fetch通过数据流（Stream对象）处理数据，分块读取，有利于提高网站性能，减少内存占用，对于请求大文件和网速慢的场景非常有用。XMLHttpRequest对象不支持数据流，所有数据必须放在缓存里面，不支持分块读取，必须等待全部拿到后再一次性吐出来。")]),e._v(" "),t("h4",{attrs:{id:"response对象-处理http回应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#response对象-处理http回应"}},[e._v("#")]),e._v(" Response对象：处理HTTP回应")]),e._v(" "),t("p",[e._v("（1）Response对象的同步属性，可以立即读取。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function fetchText() {\n    let response = await fetch(url);\n    console.log(response.status);\n    console.log(response.statusText);\n}\n")])])]),t("p",[e._v("response.status、response.statusText就是Response对象的同步属性。")]),e._v(" "),t("p",[e._v("标头信息（Headers）属性有以下：")]),e._v(" "),t("blockquote",[t("p",[e._v("Response.ok")]),e._v(" "),t("p",[e._v("Response.status")]),e._v(" "),t("p",[e._v("Response.statusText")]),e._v(" "),t("p",[e._v("Response.url")]),e._v(" "),t("p",[e._v("Response.type：返回请求的类型。可能的值如下：")]),e._v(" "),t("blockquote",[t("p",[e._v("basic: 普通请求")]),e._v(" "),t("p",[e._v("cors: 跨域请求")]),e._v(" "),t("p",[e._v("error: 网络错误")]),e._v(" "),t("p",[e._v("opaque: fetch请求的type属性为no-cores时，返回这个值。")]),e._v(" "),t("p",[e._v("opaqueredirect: fetch请求的redirect属性为manual时，返回这个值。")])]),e._v(" "),t("p",[e._v("Response.redirected")])]),e._v(" "),t("p",[e._v("（2）判断请求是否成功")]),e._v(" "),t("p",[e._v("fetch发出请求后，又一个重要的点是，只有网络错误、或者无法连接时，fetch()才会报错，其他情况都不会报错，而认为是请求成功。")]),e._v(" "),t("p",[e._v("也就是说服务器返回的状态码是4xx或者5xx，fetch()也不会报错（Promise不会变成rejected）。")]),e._v(" "),t("p",[e._v("通过Response.status属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async fetchText() {\n    let response = await fetch(url);\n    if(response.status >= 200 && response.status <= 300){\n        return await response.text()\n    }else{\n        throw new Error(response.statusText)\n    }\n}\n// 或者判断response.ok是否为true\nif(response.ok){\n    // 请求成功\n}else{\n    // 请求失败\n}\n")])])]),t("p",[e._v("（3）response对象的headers属性")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const response = await fetch(url); \nfor (let [key, value] of response.headers) { \n    console.log(`${key} : ${value}`); \n} // 或者 for (let [key, value] of response.headers.entries()) { console.log(`${key} : ${value}`); }\n")])])]),t("p",[e._v("Headers 对象提供了以下方法，用来操作标头。")]),e._v(" "),t("blockquote",[t("p",[e._v("Headers.get()：根据指定的键名，返回键值。")]),e._v(" "),t("p",[e._v("Headers.has()： 返回一个布尔值，表示是否包含某个标头。")]),e._v(" "),t("p",[e._v("Headers.set()：将指定的键名设置为新的键值，如果该键名不存在则会添加。")]),e._v(" "),t("p",[e._v("Headers.append()：添加标头。")]),e._v(" "),t("p",[e._v("Headers.delete()：删除标头。")]),e._v(" "),t("p",[e._v("Headers.keys()：返回一个遍历器，可以依次遍历所有键名。")]),e._v(" "),t("p",[e._v("Headers.values()：返回一个遍历器，可以依次遍历所有键值。")]),e._v(" "),t("p",[e._v("Headers.entries()：返回一个遍历器，可以依次遍历所有键值对（[key, value]）。")]),e._v(" "),t("p",[e._v("Headers.forEach()：依次遍历标头，每个标头都会执行一次参数函数。")])]),e._v(" "),t("comment-comment")],1)}),[],!1,null,null,null);s.default=r.exports}}]);