<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lynsey&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="This is a blog.">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0b1ac558.css" as="style"><link rel="preload" href="/blog/assets/js/app.e691cc0d.js" as="script"><link rel="preload" href="/blog/assets/js/2.ff40101d.js" as="script"><link rel="preload" href="/blog/assets/js/42.ae70df56.js" as="script"><link rel="preload" href="/blog/assets/js/16.57977c04.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.88c58f32.js"><link rel="prefetch" href="/blog/assets/js/11.2a5bc046.js"><link rel="prefetch" href="/blog/assets/js/12.937e91d6.js"><link rel="prefetch" href="/blog/assets/js/13.5e7a462d.js"><link rel="prefetch" href="/blog/assets/js/14.3acf3f2d.js"><link rel="prefetch" href="/blog/assets/js/15.ff5a6012.js"><link rel="prefetch" href="/blog/assets/js/17.11d0cbf7.js"><link rel="prefetch" href="/blog/assets/js/18.ce0c3392.js"><link rel="prefetch" href="/blog/assets/js/19.9a9dac74.js"><link rel="prefetch" href="/blog/assets/js/20.024d7d01.js"><link rel="prefetch" href="/blog/assets/js/21.410235c8.js"><link rel="prefetch" href="/blog/assets/js/22.a915e759.js"><link rel="prefetch" href="/blog/assets/js/23.970b5b8d.js"><link rel="prefetch" href="/blog/assets/js/24.2fc4281d.js"><link rel="prefetch" href="/blog/assets/js/25.39b80c8b.js"><link rel="prefetch" href="/blog/assets/js/26.f01ad796.js"><link rel="prefetch" href="/blog/assets/js/27.c8f8aec7.js"><link rel="prefetch" href="/blog/assets/js/28.fdd4c23c.js"><link rel="prefetch" href="/blog/assets/js/29.8d21b879.js"><link rel="prefetch" href="/blog/assets/js/3.ecc00d47.js"><link rel="prefetch" href="/blog/assets/js/30.ff26dacc.js"><link rel="prefetch" href="/blog/assets/js/31.aee9cefb.js"><link rel="prefetch" href="/blog/assets/js/32.a0120846.js"><link rel="prefetch" href="/blog/assets/js/33.a67f6e38.js"><link rel="prefetch" href="/blog/assets/js/34.394c62e2.js"><link rel="prefetch" href="/blog/assets/js/35.b493a779.js"><link rel="prefetch" href="/blog/assets/js/36.fea9035c.js"><link rel="prefetch" href="/blog/assets/js/37.4c14f251.js"><link rel="prefetch" href="/blog/assets/js/38.c857705d.js"><link rel="prefetch" href="/blog/assets/js/39.aecf4f9a.js"><link rel="prefetch" href="/blog/assets/js/4.78fcb44a.js"><link rel="prefetch" href="/blog/assets/js/40.db3c1b9f.js"><link rel="prefetch" href="/blog/assets/js/41.10bd9d97.js"><link rel="prefetch" href="/blog/assets/js/43.632afff4.js"><link rel="prefetch" href="/blog/assets/js/44.c0d2be41.js"><link rel="prefetch" href="/blog/assets/js/45.77132c70.js"><link rel="prefetch" href="/blog/assets/js/46.be9db988.js"><link rel="prefetch" href="/blog/assets/js/47.daba60b5.js"><link rel="prefetch" href="/blog/assets/js/48.45467417.js"><link rel="prefetch" href="/blog/assets/js/49.b74107e3.js"><link rel="prefetch" href="/blog/assets/js/5.1a0155f1.js"><link rel="prefetch" href="/blog/assets/js/50.ff2f86ca.js"><link rel="prefetch" href="/blog/assets/js/51.b3826be8.js"><link rel="prefetch" href="/blog/assets/js/52.c8c83d00.js"><link rel="prefetch" href="/blog/assets/js/53.d1de3c36.js"><link rel="prefetch" href="/blog/assets/js/54.e6a8767e.js"><link rel="prefetch" href="/blog/assets/js/55.adc1b0db.js"><link rel="prefetch" href="/blog/assets/js/56.6a606394.js"><link rel="prefetch" href="/blog/assets/js/57.b116988c.js"><link rel="prefetch" href="/blog/assets/js/58.ac12ac69.js"><link rel="prefetch" href="/blog/assets/js/59.a31bd562.js"><link rel="prefetch" href="/blog/assets/js/6.7d3ba688.js"><link rel="prefetch" href="/blog/assets/js/60.b230204c.js"><link rel="prefetch" href="/blog/assets/js/61.a90e8718.js"><link rel="prefetch" href="/blog/assets/js/62.e7e504de.js"><link rel="prefetch" href="/blog/assets/js/63.632466f1.js"><link rel="prefetch" href="/blog/assets/js/64.141cbd1b.js"><link rel="prefetch" href="/blog/assets/js/65.052937c4.js"><link rel="prefetch" href="/blog/assets/js/66.e72a94d4.js"><link rel="prefetch" href="/blog/assets/js/67.66e928d1.js"><link rel="prefetch" href="/blog/assets/js/68.97437ea4.js"><link rel="prefetch" href="/blog/assets/js/69.a46a3b37.js"><link rel="prefetch" href="/blog/assets/js/7.e4420320.js"><link rel="prefetch" href="/blog/assets/js/70.1744a438.js"><link rel="prefetch" href="/blog/assets/js/71.4289e552.js"><link rel="prefetch" href="/blog/assets/js/72.00fcd951.js"><link rel="prefetch" href="/blog/assets/js/73.d0f7aa19.js"><link rel="prefetch" href="/blog/assets/js/74.217c6e51.js"><link rel="prefetch" href="/blog/assets/js/75.f5cae8bd.js"><link rel="prefetch" href="/blog/assets/js/8.7effe995.js"><link rel="prefetch" href="/blog/assets/js/9.a66b4ef5.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0b1ac558.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="https://cdn4.buysellads.net/uu/1/41334/1550855401-cc_light.png" alt="Lynsey's blog" class="logo"> <span class="site-name can-hide">Lynsey's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/src/前端/基础知识/DNS/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/src/手写题/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/blog/src/算法题/JS/" class="nav-link">
  算法题
</a></div><div class="nav-item"><a href="/blog/src/操作手册/开发运行此项目/" class="nav-link">
  操作手册
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/src/前端/基础知识/DNS/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/src/手写题/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/blog/src/算法题/JS/" class="nav-link">
  算法题
</a></div><div class="nav-item"><a href="/blog/src/操作手册/开发运行此项目/" class="nav-link">
  操作手册
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>GIT</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>ES6技巧</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html" class="sidebar-link">ES6新特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#一、var、let、const的区别" class="sidebar-link">一、var、let、const的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#二、数组新增拓展" class="sidebar-link">二、数组新增拓展</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#三、对象新增拓展" class="sidebar-link">三、对象新增拓展</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#四、函数新增拓展" class="sidebar-link">四、函数新增拓展</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#五、set-和-map" class="sidebar-link">五、Set 和 Map</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#六、promise" class="sidebar-link">六、Promise</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#七、generator" class="sidebar-link">七、Generator</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#八、proxy" class="sidebar-link">八、Proxy</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#九、module" class="sidebar-link">九、Module</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/ES6新特性.html#十、decorator" class="sidebar-link">十、Decorator</a></li></ul></li><li><a href="/blog/src/前端/JS/ES6技巧/async和await作用.html" class="sidebar-link">async和await作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/前端/JS/ES6技巧/normalize().html" class="sidebar-link">normalize()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/前端/JS/ES6技巧/reduce.html" class="sidebar-link">reduce</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/reduce.html#_1-计算数组之和或乘积" class="sidebar-link">1.计算数组之和或乘积</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/reduce.html#_2-数组去重" class="sidebar-link">2.数组去重</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/reduce.html#_3-计算数组中每个元素出现的次数" class="sidebar-link">3.计算数组中每个元素出现的次数</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/ES6技巧/reduce.html#_4-二维数组转化为一维数组" class="sidebar-link">4.二维数组转化为一维数组</a></li></ul></li><li><a href="/blog/src/前端/JS/ES6技巧/可选链操作符.html" class="sidebar-link">可选链操作符</a></li><li><a href="/blog/src/前端/JS/ES6技巧/数组去重.html" class="sidebar-link">数组去重</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/前端/JS/ES6技巧/空值合并运算符.html" class="sidebar-link">空值合并运算符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/前端/JS/ES6技巧/过滤数组中值为false的值.html" class="sidebar-link">过滤数组中值为false的值</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>JS一行代码</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Promise</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/src/前端/JS/call、apply、bind.html" class="active sidebar-link">call、apply、bind</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/call、apply、bind.html#区别" class="sidebar-link">区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/call、apply、bind.html#用法" class="sidebar-link">用法</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/call、apply、bind.html#手写" class="sidebar-link">手写</a></li></ul></li><li><a href="/blog/src/前端/JS/js获取当天0点时间戳兼容IE.html" class="sidebar-link">js获取当天0点时间戳兼容IE</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/前端/JS/函数柯里化.html" class="sidebar-link">函数柯里化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/前端/JS/防抖&amp;节流.html" class="sidebar-link">防抖&amp;节流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/防抖&amp;节流.html#防抖-debounce" class="sidebar-link">防抖（debounce）</a></li><li class="sidebar-sub-header"><a href="/blog/src/前端/JS/防抖&amp;节流.html#节流-throttle" class="sidebar-link">节流（throttle）</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node.js</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/src/%E5%89%8D%E7%AB%AF/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础知识</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h2> <ul><li>都用来改变 this 指向；</li> <li>call 、apply 在改变 this 指向的同时会执行函数，一次性的。不同的是 call 方法传递函数调用的形参是散列的形式，apply 的行参是一个数组。在传参的情况下，call 的性能要高于 apply， 因为 apply 还需要解析数组。</li> <li>bind 在改变 this 指向后是返回一个全新的绑定函数，不直接执行函数。<strong>一个函数被 bind 绑定后，那么这个返回的新函数无法再通过 call 、 apply 改变 this 指向。</strong></li></ul> <h2 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h2> <h3 id="call"><a href="#call" class="header-anchor">#</a> call</h3> <ul><li>call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</li></ul> <blockquote><p>function.call(thisArg, arg1, arg2, ...);</p> <p>[thisArg] 必填， [arg1, arg2, ...] 可选；</p> <p>在 function 函数运行时使用的 this 值，指定为 null 或 undefined 时，this 自动替换为指向全局对象。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let callObj = {
    name: '我是call'
}
function fn() {
    console.log('参数 =&gt;', ...arguments);
    console.log('name =&gt;', this.name);
}
fn.call(callObj, 1, 2, 3)
// 参数 =&gt; 1 2 3
// name =&gt; 我是call
</code></pre></div><h3 id="apply"><a href="#apply" class="header-anchor">#</a> apply</h3> <ul><li>方法调用一个具有给定 this 值的函数，以及以一个数组（或类数组对象）的形式提供参数。</li></ul> <blockquote><p>function.apply(thisArg, [argsArray]);</p> <p>[thisArg] 必填；[argsArray] 可选；</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let objApply = {
    name: '我是apply'
}
function fn() {
    console.log('参数 =&gt;', ...arguments);
    console.log('name =&gt;', this.name);
}
fn.apply(objApply, [1, 2, 3]);
// 参数 =&gt; 1 2 3
// name =&gt; 我是apply
</code></pre></div><h3 id="bind"><a href="#bind" class="header-anchor">#</a> bind</h3> <ul><li>方法创建一个新的函数，在 bind() 被调用时，这个新的函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</li></ul> <blockquote><p>function.bind(thisArg, [, arg1[, arg2[, arg3[, ...]]]])</p> <p>[thisArg]</p> <p>[arg1, arg2, arg3, ...] 当目标函数被调用时，被预置入绑定函数参数列表中的参数。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let objBind = {
    name: '我是bind'
}
let objApply = {
    name: '我是apply'
}
let callObj = {
    name: '我是call'
}
function fn() {
    console.log('参数 =&gt;', ...arguments);
    console.log('name =&gt;', this.name);
}
let bfn = fn.bind(objBind, 1, 2, 3); // 或 fn.bind(objBind)(1, 2, 3);
bfn();
// 参数 =&gt; 1 2 3
// name =&gt; 我是bind

bfn.call(objCall);
bfn.apply(objApply);
// 参数 =&gt; 1 2 3
// name =&gt; 我是bind // 无法再改变
// 参数 =&gt; 1 2 3
// name =&gt; 我是bind
</code></pre></div><h2 id="手写"><a href="#手写" class="header-anchor">#</a> 手写</h2> <h3 id="模拟实现-call"><a href="#模拟实现-call" class="header-anchor">#</a> 模拟实现 call</h3> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.myCall = function(context = window, ...args) {
    if(this === Function.prototype) {
        return undefined; // 防止直接调用
    }
    context = context || window;
    const fn = Symbol();
    context[fn] = this;
    const result = context[fn](...args);
    delete context[fn];
    return result;
}
</code></pre></div><h3 id="模拟实现-apply"><a href="#模拟实现-apply" class="header-anchor">#</a> 模拟实现 apply</h3> <p>apply 和 call 类似，参数为数组</p> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.myApply = function(context = window, args) {
    if(this === Function.prototype) {
        return undefined;
    }
    // context = context || window;
    const fn = Symbol();
    context[fn] = this;
    let result;
    if(Array.isArray(args)) {
        result = context[fn](...args);
    } else {
        result = context[fn]();
    }
    delete context[fn];
    return result;
}
</code></pre></div><h3 id="模拟实现-bind"><a href="#模拟实现-bind" class="header-anchor">#</a> 模拟实现 bind</h3> <ol><li>处理参数，返回一个闭包</li> <li>判断是否为构造函数调用，如果是则使用new调用当前函数</li> <li>如果不是，使用apply，将context和处理好的参数传入</li></ol> <div class="language- extra-class"><pre class="language-text"><code>    Function.prototype.myBind = function (context,...args1) {
      if (this === Function.prototype) {
        throw new TypeError('Error')
      }
      const _this = this
      return function F(...args2) {
        // 判断是否用于构造函数
        if (this instanceof F) {
          return new _this(...args1, ...args2)
        }
        return _this.apply(context, args1.concat(args2))
      }
    }
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Function.prototype.mybind = function () {
  if (typeof this !== 'function') throw 'Bind must be called on a function'
  let _this = this, //这里的this是原函数
    context = arguments[0],//获取要this指向的对象
    slice = Array.prototype.slice,
    args = slice.call(arguments, 1);//获取bind函数除this指向对象外的所有参数
  //返回函数    
  return function () {
    args = args.concat(slice.call(arguments))//合并bind的入参和执行时的入参
    return _this.apply(context, args)
  }
}
</code></pre></div> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">10/17/2022, 7:50:11 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/src/前端/JS/Promise/手写Promise.html" class="prev">
        手写Promise
      </a></span> <span class="next"><a href="/blog/src/前端/JS/js获取当天0点时间戳兼容IE.html">
        js获取当天0点时间戳兼容IE
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.e691cc0d.js" defer></script><script src="/blog/assets/js/2.ff40101d.js" defer></script><script src="/blog/assets/js/42.ae70df56.js" defer></script><script src="/blog/assets/js/16.57977c04.js" defer></script>
  </body>
</html>
