<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lynsey&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="This is a blog.">
    
    <link rel="preload" href="/blog/assets/css/0.styles.ae2fffaf.css" as="style"><link rel="preload" href="/blog/assets/js/app.56ce6fa7.js" as="script"><link rel="preload" href="/blog/assets/js/2.9c076bee.js" as="script"><link rel="preload" href="/blog/assets/js/75.18fe6eaa.js" as="script"><link rel="preload" href="/blog/assets/js/19.aff3d43c.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.396dec3a.js"><link rel="prefetch" href="/blog/assets/js/11.3fab1c42.js"><link rel="prefetch" href="/blog/assets/js/12.b56b3a4e.js"><link rel="prefetch" href="/blog/assets/js/13.ab977949.js"><link rel="prefetch" href="/blog/assets/js/14.6f2bbf2d.js"><link rel="prefetch" href="/blog/assets/js/15.3335ec1e.js"><link rel="prefetch" href="/blog/assets/js/16.40615b64.js"><link rel="prefetch" href="/blog/assets/js/17.9836292f.js"><link rel="prefetch" href="/blog/assets/js/18.118594fd.js"><link rel="prefetch" href="/blog/assets/js/20.6d14c303.js"><link rel="prefetch" href="/blog/assets/js/21.e96f1749.js"><link rel="prefetch" href="/blog/assets/js/22.5780b9bd.js"><link rel="prefetch" href="/blog/assets/js/23.df68349b.js"><link rel="prefetch" href="/blog/assets/js/24.82bcdf3a.js"><link rel="prefetch" href="/blog/assets/js/25.231ccd61.js"><link rel="prefetch" href="/blog/assets/js/26.7d30c44b.js"><link rel="prefetch" href="/blog/assets/js/27.1d93091a.js"><link rel="prefetch" href="/blog/assets/js/28.0c35ca68.js"><link rel="prefetch" href="/blog/assets/js/29.0197e186.js"><link rel="prefetch" href="/blog/assets/js/3.20f64ed7.js"><link rel="prefetch" href="/blog/assets/js/30.ac51d80a.js"><link rel="prefetch" href="/blog/assets/js/31.c0e9ad8d.js"><link rel="prefetch" href="/blog/assets/js/32.28d8875e.js"><link rel="prefetch" href="/blog/assets/js/33.78102ecd.js"><link rel="prefetch" href="/blog/assets/js/34.215a0cb5.js"><link rel="prefetch" href="/blog/assets/js/35.1e7f9ac5.js"><link rel="prefetch" href="/blog/assets/js/36.f7aee3d6.js"><link rel="prefetch" href="/blog/assets/js/37.df9cd1ce.js"><link rel="prefetch" href="/blog/assets/js/38.05ef9d76.js"><link rel="prefetch" href="/blog/assets/js/39.3ede578e.js"><link rel="prefetch" href="/blog/assets/js/4.21ebb698.js"><link rel="prefetch" href="/blog/assets/js/40.bf48ae1a.js"><link rel="prefetch" href="/blog/assets/js/41.b6eee169.js"><link rel="prefetch" href="/blog/assets/js/42.a9f709dc.js"><link rel="prefetch" href="/blog/assets/js/43.2c420d2c.js"><link rel="prefetch" href="/blog/assets/js/44.2eca3395.js"><link rel="prefetch" href="/blog/assets/js/45.a8ff9280.js"><link rel="prefetch" href="/blog/assets/js/46.cfb6410e.js"><link rel="prefetch" href="/blog/assets/js/47.abd97eb6.js"><link rel="prefetch" href="/blog/assets/js/48.fc875ce0.js"><link rel="prefetch" href="/blog/assets/js/49.2727c3c9.js"><link rel="prefetch" href="/blog/assets/js/5.a58502f2.js"><link rel="prefetch" href="/blog/assets/js/50.65a29cb1.js"><link rel="prefetch" href="/blog/assets/js/51.e7e704f7.js"><link rel="prefetch" href="/blog/assets/js/52.a72b83f0.js"><link rel="prefetch" href="/blog/assets/js/53.f2d469a7.js"><link rel="prefetch" href="/blog/assets/js/54.965662e5.js"><link rel="prefetch" href="/blog/assets/js/55.d5ff2818.js"><link rel="prefetch" href="/blog/assets/js/56.6f58ef6f.js"><link rel="prefetch" href="/blog/assets/js/57.d8ae746b.js"><link rel="prefetch" href="/blog/assets/js/58.2c0df091.js"><link rel="prefetch" href="/blog/assets/js/59.80c872ac.js"><link rel="prefetch" href="/blog/assets/js/6.db12bcbc.js"><link rel="prefetch" href="/blog/assets/js/60.f1967277.js"><link rel="prefetch" href="/blog/assets/js/61.4b648bbc.js"><link rel="prefetch" href="/blog/assets/js/62.a26f2de2.js"><link rel="prefetch" href="/blog/assets/js/63.227eec3f.js"><link rel="prefetch" href="/blog/assets/js/64.375f7735.js"><link rel="prefetch" href="/blog/assets/js/65.598724fb.js"><link rel="prefetch" href="/blog/assets/js/66.3917635c.js"><link rel="prefetch" href="/blog/assets/js/67.2d078441.js"><link rel="prefetch" href="/blog/assets/js/68.53961b2d.js"><link rel="prefetch" href="/blog/assets/js/69.8884a264.js"><link rel="prefetch" href="/blog/assets/js/7.d7d22019.js"><link rel="prefetch" href="/blog/assets/js/70.0d93e1a8.js"><link rel="prefetch" href="/blog/assets/js/71.13ed765e.js"><link rel="prefetch" href="/blog/assets/js/72.f1118f0a.js"><link rel="prefetch" href="/blog/assets/js/73.6af42574.js"><link rel="prefetch" href="/blog/assets/js/74.afb7e852.js"><link rel="prefetch" href="/blog/assets/js/76.e616baf5.js"><link rel="prefetch" href="/blog/assets/js/77.e53ce15a.js"><link rel="prefetch" href="/blog/assets/js/78.086f1d22.js"><link rel="prefetch" href="/blog/assets/js/79.9772a3bd.js"><link rel="prefetch" href="/blog/assets/js/8.634de971.js"><link rel="prefetch" href="/blog/assets/js/80.a8342137.js"><link rel="prefetch" href="/blog/assets/js/81.ddc158af.js"><link rel="prefetch" href="/blog/assets/js/82.525f63c1.js"><link rel="prefetch" href="/blog/assets/js/9.9cf7d497.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.ae2fffaf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="https://github.com/dreamlixia/blog/raw/master/images/title.jpeg" alt="Lynsey's blog" class="logo"> <span class="site-name can-hide">Lynsey's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/src/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/src/面试题/HTML/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/blog/src/手写题/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/blog/src/算法题/JS/" class="nav-link">
  算法题
</a></div><div class="nav-item"><a href="/blog/src/操作手册/开发运行此项目/" class="nav-link">
  操作手册
</a></div><div class="nav-item"><a href="/blog/src/主页/" class="nav-link">
  主页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/src/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/src/面试题/HTML/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/blog/src/手写题/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/blog/src/算法题/JS/" class="nav-link">
  算法题
</a></div><div class="nav-item"><a href="/blog/src/操作手册/开发运行此项目/" class="nav-link">
  操作手册
</a></div><div class="nav-item"><a href="/blog/src/主页/" class="nav-link">
  主页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/src/面试题/CSS.html" class="sidebar-link">CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/CSS.html#css引入的方式有哪些-link和-import的区别是什么" class="sidebar-link">CSS引入的方式有哪些，link和@import的区别是什么</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/CSS.html#less-sass-scss-stylus-css预处理器" class="sidebar-link">Less Sass Scss Stylus（css预处理器）</a></li></ul></li><li><a href="/blog/src/面试题/ECharts.html" class="sidebar-link">ECharts</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/ECharts.html#响应容器大小的变化" class="sidebar-link">响应容器大小的变化</a></li></ul></li><li><a href="/blog/src/面试题/HTML.html" class="sidebar-link">HTML</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html语义化的理解" class="sidebar-link">html语义化的理解</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#iframe-标签有哪些缺点-为什么要尽量少用-iframe-标签" class="sidebar-link">&lt;iframe\&gt;标签有哪些缺点？为什么要尽量少用&lt;iframe\&gt;标签</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#label的作用是什么-怎么用的" class="sidebar-link">Label的作用是什么？怎么用的</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#meta-标签的viewport的作用和原理是什么" class="sidebar-link">&lt;meta\&gt;标签的viewport的作用和原理是什么</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#meta的基本应用" class="sidebar-link">meta的基本应用</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html5的新特性" class="sidebar-link">html5的新特性</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#本地存储cookie、localstorage、sessionstorage的区别及优缺点" class="sidebar-link">本地存储cookie、localStorage、sessionStorage的区别及优缺点</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#前端页面分为哪三层" class="sidebar-link">前端页面分为哪三层</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#前端需要注意哪些seo" class="sidebar-link">前端需要注意哪些SEO</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#介绍下你对浏览器内核的理解" class="sidebar-link">介绍下你对浏览器内核的理解</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html标签中的src和href有什么区别" class="sidebar-link">html标签中的src和href有什么区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html渲染页面的过程" class="sidebar-link">html渲染页面的过程</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#vw、vh、em、rem" class="sidebar-link">vw、vh、em、rem</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#bfc" class="sidebar-link">BFC</a></li></ul></li><li><a href="/blog/src/面试题/JavaScript.html" class="active sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#异步加载的几种方式" class="sidebar-link">异步加载的几种方式</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#async和defer的区别" class="sidebar-link">async和defer的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#solid五大设计原则" class="sidebar-link">solid五大设计原则</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#hash路由和history路由的区别" class="sidebar-link">hash路由和history路由的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#防抖-debounce" class="sidebar-link">防抖（debounce）</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#节流-throttle" class="sidebar-link">节流（throttle）</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#介绍下promise和all方法" class="sidebar-link">介绍下Promise和all方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#promise和async-await的区别" class="sidebar-link">promise和async await的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#数组的常用方法" class="sidebar-link">数组的常用方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#reduce这个方法通常用于什么场景" class="sidebar-link">reduce这个方法通常用于什么场景？</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#字符串的常用方法" class="sidebar-link">字符串的常用方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#对象的常用方法" class="sidebar-link">对象的常用方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#new和object-create-的区别" class="sidebar-link">new和Object.create()的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#对this对象的理解" class="sidebar-link">对this对象的理解</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#深浅拷贝" class="sidebar-link">深浅拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#事件委托-事件代理" class="sidebar-link">事件委托（事件代理）</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#js数据类型" class="sidebar-link">js数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#null-和-undefined-区别" class="sidebar-link">null 和 undefined 区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#判断数据类型的四种方式" class="sidebar-link">判断数据类型的四种方式</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#object-is-与比较操作符-、-的区别" class="sidebar-link">Object.is() 与比较操作符 “===”、“==” 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#escape、encodeuri、encodeuricomponent-的区别" class="sidebar-link">escape、encodeURI、encodeURIComponent 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#什么是尾调用-使用尾调用有什么好处" class="sidebar-link">什么是尾调用，使用尾调用有什么好处?</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#js判断空对象" class="sidebar-link">JS判断空对象</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#代码检查工具-husky-eslint-prettier-lint-staged" class="sidebar-link">代码检查工具 husky eslint prettier lint-staged</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#es6-map-和-weakmap-的区别" class="sidebar-link">es6 Map()和 WeakMap()的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#setinterval和settimeout的区别" class="sidebar-link">setInterval和setTimeout的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#test和includes哪个性高更高" class="sidebar-link">test和includes哪个性高更高？</a></li></ul></li><li><a href="/blog/src/面试题/Node.html" class="sidebar-link">Node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/Node.html#node环境与浏览器环境的区别" class="sidebar-link">node环境与浏览器环境的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/Node.html#node" class="sidebar-link">Node</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/Node.html#v8引擎" class="sidebar-link">V8引擎</a></li></ul></li><li><a href="/blog/src/%E9%9D%A2%E8%AF%95%E9%A2%98/" aria-current="page" class="sidebar-link">面试题</a></li><li><a href="/blog/src/面试题/React.html" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/React.html#csdn-react-21年常见面试题" class="sidebar-link">CSDN React 21年常见面试题</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/React.html#前端进阶笔记" class="sidebar-link">前端进阶笔记</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/React.html#类组件和函数组件的区别" class="sidebar-link">类组件和函数组件的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/React.html#受控组件和非受控组件" class="sidebar-link">受控组件和非受控组件</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/React.html#react-hook使用的限制是什么-为什么有这样的限制" class="sidebar-link">React hook使用的限制是什么？ 为什么有这样的限制</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/React.html#fiber节点保存数据" class="sidebar-link">fiber节点保存数据</a></li></ul></li><li><a href="/blog/src/面试题/Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/blog/src/面试题/低代码.html" class="sidebar-link">低代码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/低代码.html#提供的功能-形态" class="sidebar-link">提供的功能，形态</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/低代码.html#作用" class="sidebar-link">作用</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/低代码.html#代表产品" class="sidebar-link">代表产品</a></li></ul></li><li><a href="/blog/src/面试题/小程序.html" class="sidebar-link">小程序</a></li><li><a href="/blog/src/面试题/网络安全.html" class="sidebar-link">网络安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/网络安全.html#sql注入" class="sidebar-link">SQL注入</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/网络安全.html#xss攻击" class="sidebar-link">XSS攻击</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/网络安全.html#如何避免-cookie信息被盗取" class="sidebar-link">如何避免 cookie信息被盗取</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/网络安全.html#csrf攻击" class="sidebar-link">CSRF攻击</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/网络安全.html#你所了解的web攻击技术有哪些" class="sidebar-link">你所了解的Web攻击技术有哪些</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="异步加载的几种方式"><a href="#异步加载的几种方式" class="header-anchor">#</a> 异步加载的几种方式</h2> <ol><li>defer: script被异步加载后并不会立即执行，而是等待文档被解析后执行。
<ul><li>只适用于外联脚本，如果script没有制定src属性，只是内联脚本，不要使用defer；</li> <li>如果有多个声明了defer的sript，则会按顺序下载和执行；</li> <li>defer脚本会在DOMContentLoader和load事件之前执行</li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;&gt;defer&lt;/script&gt;
</code></pre></div><ol start="2"><li>async: html5为script元素定义的属性，只能异步加载外部的链接文件，不能加载内部脚本
<ul><li>在js文件加载完后立即执行；</li> <li>如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序；</li> <li>async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序</li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;
</code></pre></div><ol start="3"><li>动态创建script标签，按需加载，节省资源，在需要用到的时候再去引入。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function loadScript(url, callback) {
    var script = document.createElement('script');
    if(script.readyState) {
        script.onreadystatechange = function() {
            if(script.readyState == 'loaded' || script.readyState == 'complate') {
                callback();
            }
        }
    } else {
        script.onload = function() {
            callback();
        }
    }
    script.url = url;
    document.body.appendChild(script);
}
</code></pre></div><h2 id="async和defer的区别"><a href="#async和defer的区别" class="header-anchor">#</a> async和defer的区别</h2> <p>相同点：都是异步加载scrit，加载过程都不会阻塞html的解析。</p> <p>不同点：</p> <ol><li>defer会在html解析完执行，DomContentLoaded之前执行，async是在加载完立即执行，执行的过程仍会阻塞后续html的解析；</li> <li>async不能保证script标签的执行顺序，defer在html解析完之后按顺序执行；</li></ol> <p>总结：</p> <ol><li>通常情况下defer的使用频率较高，他能保证scrit之间的变量依赖；</li> <li>需要注意的是，async script的资源请求是异步的，但script的执行仍然会阻塞后续渲染（单线程），defer是在html渲染完之后执行的所以不会阻塞后续的html解析。</li></ol> <h2 id="solid五大设计原则"><a href="#solid五大设计原则" class="header-anchor">#</a> solid五大设计原则</h2> <h4 id="单一职责原则-the-single-responsibility-principle-srp"><a href="#单一职责原则-the-single-responsibility-principle-srp" class="header-anchor">#</a> 单一职责原则 The Single-Responsibility Principle (SRP)</h4> <blockquote><p>单一职责原则，就是说一个类仅有一个引起它变化的原因。也有人把它解释为只做一件事情</p></blockquote> <h4 id="开放闭合原则-the-open-closed-principle-ocp"><a href="#开放闭合原则-the-open-closed-principle-ocp" class="header-anchor">#</a> 开放闭合原则 The Open/Closed Principle (OCP)</h4> <blockquote><p>所有的系统在其生命周期里都会改变，需求会变是正常的，好的系统不会拒绝变化，只会需要添加code或者修改很少的code就能支持这些变化。</p> <p>它强调对扩展开放，对修改闭合。办法：</p> <p>抽象、多态</p></blockquote> <h4 id="里氏替换原则-the-liskov-substitution-principle-lsp"><a href="#里氏替换原则-the-liskov-substitution-principle-lsp" class="header-anchor">#</a> 里氏替换原则 The Liskov Substitution Principle (LSP)</h4> <blockquote><p>自类型必须能够替换它的基类型。</p> <p>强调继承。</p></blockquote> <h4 id="接口分离原则-the-interface-segregation-principle-isp"><a href="#接口分离原则-the-interface-segregation-principle-isp" class="header-anchor">#</a> 接口分离原则 The Interface Segregation Principle (ISP)</h4> <blockquote><p>客户端不应该被迫依赖于它不使用的方法。简单来说就是更小更具体的瘦接口比庞大臃肿的胖接口好。</p></blockquote> <h4 id="依赖倒置原则-the-dependency-inversion-principle-dip"><a href="#依赖倒置原则-the-dependency-inversion-principle-dip" class="header-anchor">#</a> 依赖倒置原则 The Dependency-Inversion Principle (DIP)</h4> <blockquote><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖于抽象。低层模块不应该影响高层模块，否则高层模块很难做到复用。</p></blockquote> <h2 id="hash路由和history路由的区别"><a href="#hash路由和history路由的区别" class="header-anchor">#</a> hash路由和history路由的区别</h2> <p>1.hash路由在地址栏URL上有#，而history路由没有会好看一点</p> <p>2.我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。</p> <p>3.hash路由支持低版本的浏览器，而history路由是HTML5新增的API。</p> <p>4.hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。</p> <p>5.history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState（）和replaceState（）方法（需要特定浏览器的支持），它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。</p> <h2 id="防抖-debounce"><a href="#防抖-debounce" class="header-anchor">#</a> 防抖（debounce）</h2> <p>不管事件的触发频率多高，一定在事件触发的 n 秒后才执行，如果你在事件触发后 n 秒内又触发了这个事件，那么以新的时间为准，n 秒后再执行。</p> <div class="language- extra-class"><pre class="language-text"><code>function debounce(event, time) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            event.apply(this, args);
        }, time);
    }
}
</code></pre></div><p>有时候我们需要立即执行一次函数，再等后面事件触发后等待 n 秒执行，我们给 debounce 函数一个 flag 标示。</p> <div class="language- extra-class"><pre class="language-text"><code>function debounce(event, time) {
    let timer = null;
    let flag = true;
    return function(...args) {
        clearTimeout(timer);
        if(flag &amp;&amp; !timer) {
            event.apply(this, args);
            flag = false;
        }
        timer = setTimeout(() =&gt; {
            event.apply(this, args);
        }, time);
    }
}
</code></pre></div><h2 id="节流-throttle"><a href="#节流-throttle" class="header-anchor">#</a> 节流（throttle）</h2> <p>不管事件的触发频率有多高，只在单位时间内执行一次。</p> <p><span style="text-decoration:underline;color:blue;">时间戳</span>和定时器结合，第一次和最后一次都会触发的版本。</p> <div class="language- extra-class"><pre class="language-text"><code>function throttle(event, time) {
    let pre = 0; // 记录上次的时间
    let timer = null;
    return function(...args) {
        if(Date.now() - pre &gt; time) { // 当前时间-上次时间 &gt; 等待时间
            clearTimeout(timer);
            pre = Date.now(); // 重置上次的时间
            event.apply(this, args); // 执行函数
        } else if(!timer) {
            timer = setTimeout(() =&gt; {
                event.apply(this, args);
            }, time);
        }
    }
}
</code></pre></div><h2 id="介绍下promise和all方法"><a href="#介绍下promise和all方法" class="header-anchor">#</a> 介绍下Promise和all方法</h2> <p>Promise是异步编程的一种解决方案。有以下两个特点，对象的状态不受外界影响和一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。Promise对象是一个构造函数，用来生成promise实例，接受一个函数作为参数，该函数的两个参数分别是resolve和reject。promise的方法有then、catch、finally、resolve、reject等。</p> <p>Promise.all()方法可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功时返回一个数组，失败的时候则返回最先被reject失败状态的值。</p> <p>需要特别注意的是， Promise.all获得的成功结果的数据里面的数据顺序和Promise.all接收到的数组顺序是一致的，即使前面的结果后返回，得到的数组顺序也是在前的。适用场景：前端开发请求数据的过程中，发送多个请求并根据请求顺序获取和使用数据。</p> <h2 id="promise和async-await的区别"><a href="#promise和async-await的区别" class="header-anchor">#</a> promise和async await的区别</h2> <p>Promise的出现解决了传统callback函数导致的地域回调问题，但他的语法导致了它向纵向发展成了一个回调连，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使异步代码看起来像同步代码，await的本质是可以提供等同于“同步效果”的等待异步返回能力的语法糖，只有这一句执行完，才会执行下一句。</p> <p>async await与Promise一样，是非阻塞的。</p> <p>async await是基于Promise实现的，可以说是改良版的Promise，他不能用于普通的回调函数。</p> <h2 id="数组的常用方法"><a href="#数组的常用方法" class="header-anchor">#</a> 数组的常用方法</h2> <ol><li>push(): 后增一个或多个元素，返回新增后的数组长度，改变原数组；</li> <li>unshift()： 前增一个或多个元素，返回新增后的数组长度，改变原数组；</li> <li>pop()： 删除并返回数组的最后一个元素，返回删除的元素，若数组为空，返回undefined，改变原数组；</li> <li>shift()：删除并返回数组的第一个元素，返回删除的元素，若数组为空，返回undefined，改变原数组；</li> <li>slice()：按条件查找内容
<ul><li>slice(n, m): n其实下标，m结束下标，包含起始，不包含结束，截取出中间的内容，返回一个新数组，不改变原数组；</li> <li>slice(n): 从n截取到末尾；</li> <li>slice(0): 从头到尾截取，原样输出，可用于数组的克隆；</li> <li>slice(-n, -m): 支持负数，代表从末尾开始数第n位至第m位，截取中间的内容。</li></ul></li> <li>splice()：添加或删除数组中的元素
<ul><li>splice(n, howmany, arr1, arr2, ...): n起始下标，howmany删除长度，可以为0，代表不删除元素，arr1,arr2为新增的数组，改变原数组；</li></ul></li> <li>concat()： 拼接，合并两个或者多个数组，生成一个新的数组，不改变原数组；</li> <li>join()： 将数组的每一项用指定字符链接起来形成一个字符串，默认链接符卫','逗号；
<ul><li>join(): var arr = [1,2,3]; var str = arr.join(); // str = '1,2,3'</li> <li>join('-'): var arr = [1,2,3]; var str = arr.join('-'); // str = '1-2-3'</li></ul></li> <li>reverse(): 倒序数组，改变原数组；</li> <li>sort()： 排序，按照字符Unicode码进行排序，改变原数组；
<ul><li>从小到大排序： arr.sort((a, b) =&gt; a - b)</li> <li>从大到小排序： arr.sort((a, b) =&gt; b - a)</li> <li>按照数组对象中某个值进行排序：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var arr = [
    { name: '名字一', age: '13' },
    { name: '名字二', age: '12' },
    { name: '名字三', age: '10' },
]
function compare(param) {
    return function(a, b) {
        return a[param] - b[param]
    }
}
arr.sort(compare('age')) 
// arr = [
//    { name: '名字三', age: '10' }
//    { name: '名字二', age: '12' },
//    { name: '名字一', age: '13' },
// ]
</code></pre></div></li> <li>map()：原数组的每一项执行函数后，返回一个新的数组，有返回值，不改变原数组；</li> <li>forEach()： 没有返回值, 改变原数组；</li> <li>filter()： 过滤数组中符合条件的元素并返回一个新的数组；</li> <li>every(function)：对数组的每一项进行判断，如果每一项都符合则返回true，否则返回false；
<ul><li>从迭代开始，一旦有一个不符合条件，就返回false，不继续迭代下去</li></ul></li> <li>some(function)：对数组的任一项进行判断，如果有一项符合就返回true，都不符合则返回false；
<ul><li>一直在查找符合条件的值，一旦找到，则不继续迭代下去</li></ul></li> <li>reduce()： 接收一个函数作为累加器，最终计算为一个值；</li> <li>indexOf()：检测当前值在数组中第一次出现的位置索引，不改变原数组；
<ul><li>indexOf(item, start): item查找的元素，start从这个位置开始检索，找不到返回-1</li></ul></li> <li>includes()：判断一个数组是否包含一个指定的值，返回布尔值，不改变原数组；</li></ol> <h2 id="reduce这个方法通常用于什么场景"><a href="#reduce这个方法通常用于什么场景" class="header-anchor">#</a> reduce这个方法通常用于什么场景？</h2> <ol><li>计算数组元素之和或乘积；</li> <li>数组去重；</li> <li>计算数组中元素出现的次数；</li> <li>将二维或多维数组转化为一维数组；</li> <li>数组对象里的属性求和；</li></ol> <h2 id="字符串的常用方法"><a href="#字符串的常用方法" class="header-anchor">#</a> 字符串的常用方法</h2> <ol><li><p>charAt(index)：返回字符串中指定位置的字符；</p></li> <li><p>charCodeAt()：没有参数，str.charCodeAt(); 返回对应字符的ASCII码，如有多个值，则返回字符串中第一个值的ASCII码；</p></li> <li><p>fromCharCode(ASCII码)：String.fromCharCode(65); 填入ASCII码，就会得到对应的字符；</p></li> <li><p>includes(searchValue， start)：用于判断字符串是否包含指定字符，返回布尔值，searchValue必填，start选填，设置查找开始的位置，默认为0；</p></li> <li><p>concat()：拼接两个或多个字符串，不改变原字符串，返回拼接后的新字符串；</p></li> <li><p>split(separtator, limit)：用于把字符串分割成字符串数组，参数可以是符号也可以是字符串中的元素，两个参数都是可选的，separtator表示字符串或正则表达式，从该参数指定的地方分割，limit 指定返回的数组的最大长度；</p></li> <li><p>slice(start, end)：提取字符串的某个部分，包含起始位置，不包含结束位置，返回新的被提取部分的字符串；</p></li> <li><p>substr(start, howmany)：from开始裁切的下标，howmany要裁切的长度；</p></li> <li><p>substring(from, to)：from必须，to可选，不支持负数，提取两个指定字符之间的字符，to不填表示到结尾；</p></li> <li><p>indexOf(searchValue, start)：返回某个指定字符在字符串中首次出现的位置，没有匹配到返回-1， start选填；</p></li> <li><p>lastIndexOf()：同上，倒序查找；</p></li> <li><p>search()：检索字符串中的指定字符，或于正则表达式相匹配的字符串，返回起始位置下标；</p></li> <li><p>match()：可在字符串中根据正则找到一个或者多个匹配的值；</p></li> <li><p>trim()：去除收尾空格，没有参数；</p></li> <li><p>toLowerCase()：转化成小写；</p></li> <li><p>toUpperCase()：转化成大写；</p></li> <li><p>replace(searchValue, newValue)：用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子串；</p></li> <li><p>replaceAll()：该函数会替换掉所有匹配到的子字符串；</p></li> <li><p>repeat(n)：复制指定次数, var str = 'Hello'; var s = str.repeat(2); // s = 'HelloHello'</p></li></ol> <h2 id="对象的常用方法"><a href="#对象的常用方法" class="header-anchor">#</a> 对象的常用方法</h2> <ol><li>new：new对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 1.创建控对象后添加属性
const obj = {}
obj.uname = 'name'
obj.fn = () =&gt; {
    console.log('ggg')
}
console.log(obj)// { uname: 'name', fn: ƒ }
// 2. 创建对象并且直接添加属性(常用)
const obj1 = {
    uname: 'name',
    fn: () =&gt; {
        console.log('ggg')
    }
}
console.log(obj1) // { uname: 'name', fn: ƒ }
</code></pre></div><ol start="2"><li>Object.create(Person.prototype, {})：创建一个新对象，使用第一个参数来提供新创建对象的_proto__(以第一个参数作为对象的构造函数的原型对象)，第二个参数为可选参数，添加到新创建的对象中的属性；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const a = Object.create(Person.prototype, {
    age: {
        value: 12,
        writable: true,
        configurable: true
    }
})
</code></pre></div><h2 id="new和object-create-的区别"><a href="#new和object-create-的区别" class="header-anchor">#</a> new和Object.create()的区别</h2> <p>new产生的对象，优化获取构造函数上的属性，找不到才回去原型上找；</p> <p>如果构造函数中以及原型上都没有对应的属性，就会报错；</p> <p>Object.create() 产生的对象，只会在原型上进行查找属性，原型上没有对应的属性，就会报错；</p> <ol start="3"><li><p>delete：删除属性，const o = { p: 10, m: 20 }; delete o.p; console.log(o); // { m: 20 }</p></li> <li><p>Object.assign(target, ...sources)：将所有可枚举的自身属性从一个或多个源对象复制到目标对象，返回修改后的对象；</p></li> <li><p>Object.getOwnPropertyNames()：返回自有属性的名称（不管是不是可枚举的）</p></li> <li><p>for in：遍历对象中所有的可枚举属性（包括自身属性和继承属性）</p></li> <li><p>Object.keys(obj)：返回给定对象自己的可枚举属性名称的数组；</p></li> <li><p>Object.values(obj)：返回给定对象自己的可枚举属性值的数组；</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>const object2 = {
    a: 'a',
    b: 'b',
    c: 'c'
}
Object.values(object2); // ['a', 'b', 'c'] // 按顺序
</code></pre></div><ol start="9"><li>Object.entries(obj)：返回给定对象自己的可枚举属性[key, value]的数组</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const object1 = { name: 'David', age: 23 }
Object.entries(object1) // [['name', 'David'], ['age', 23]]
</code></pre></div><ol start="10"><li>Object.fromEntries(iterable)：参数iterable类似Array、Map或者其他实现了可迭代协议的可迭代对象，返回一个由该迭代对象条目提供对应属性的新对象。该方法把键值对列表转换为一个对象，与Object.entries()相反。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const entries = new Map([
    [ 'name', '姓名' ],
    [ 'age',  13 ]
])
const obj = Object.fromEntries(entries); // { name: '姓名', age: 13 } 
</code></pre></div><ol start="11"><li>Object.prototype.hasOwnProperty(prop)：返回一个布尔值，指示对象是否具有指定的属性作为他自己的属性，如果是对象的直接属性，则返回true，即使值为null或未定义；如果该属性是继承的或根本没有声明，则返回false；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const object3 = {}
object3.prototype1 = 1
Object.prototype.hasOwnProperty('prototype1'); // true
Object.prototype.hasOwnProperty('toString'); // false
</code></pre></div><ol start="12"><li><p>Object.prototype.toString()：返回一个表示对象的字符串。</p></li> <li><p>Object.is(val1, val2)：判读两个值是否相同，返回布尔值；</p></li></ol> <h2 id="对this对象的理解"><a href="#对this对象的理解" class="header-anchor">#</a> 对this对象的理解</h2> <p>this是执行上下文中的一个属性，他指向最后一次调用这个方法的对象。在实际开发中，this的指向可以通过四种调用模式来判断。</p> <ol><li>函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用，this指向全局对象；</li> <li>方法调用模式，如果一个函数作为一个对象的方法来调用，this指向这个对象；</li> <li>构造器调用模式，如果一个函数用new调用，函数执行前会新创建一个对象，this指向这个新创建的对象。</li> <li>apply、call和bind调用模式，这三个方法都可以显示的指定调用函数的this指向；
<ul><li>apply方法接收两个参数，一个是this绑定的对象，第二个是参数数组；</li> <li>call方法接收的参数，一个是this绑定的对象，其余是逐个列举的传入函数执行的参数；</li> <li>bind方法接收一个对象，返回一个this绑定了传入对象的新函数，这个函数的this指向除了使用new时会被改变，其他情况都不会改变。</li></ul></li></ol> <ul><li>优先级： 构造器调用模式 &gt; apply &gt; call &gt; bind &gt; 方法调用模式 &gt; 函数调用模式</li></ul> <h2 id="深浅拷贝"><a href="#深浅拷贝" class="header-anchor">#</a> 深浅拷贝</h2> <p>浅拷贝：创建一个对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本数据类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了这个地址中的值，另一个就会影响。</p> <p>深拷贝：将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，并且修改这个对象不会影响原对象。</p> <h2 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="header-anchor">#</a> 事件委托（事件代理）</h2> <p>即是把原本需要绑定在子元素的响应事件（click、keydown…）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p> <p>事件委托的优点：</p> <ul><li>可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件。</li> <li>可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</li></ul> <h2 id="js数据类型"><a href="#js数据类型" class="header-anchor">#</a> js数据类型</h2> <p>共有八种数据类型，分别是 Undefined、Null、Boolean、 Number、String、Object、Symbol、BigInt。</p> <p>其中 Symbol 和 BigInt 是 ES6 中新增的数据类型。</p> <p>这些数据可以分为原始数据类型和引用数据类型:</p> <ul><li>栈: <strong>原始数据类型(Undefined、Null、Boolean、Number、String)</strong></li> <li>堆: <strong>引用数据类型(对象、数组和函数)</strong></li></ul> <p>两种类型的区别在于存储位置的不同:</p> <ul><li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间 小、大小固定，属于被频繁使用数据，所以放入栈中存储;</li> <li>引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固 定。如果存储在栈中，将会影响程序运行的性能;引用数据类型在栈 中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引 用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul> <h2 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="header-anchor">#</a> null 和 undefined 区别</h2> <ul><li>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型 分别都只有一个值，就是 undefined 和 null。</li> <li>undefined 代表的含义是未定义，null 代表的含义是空对象。一般 变量声明了但还没有定义的时候会返回 undefined，null 主要用于 赋值给一些可能会返回对象的变量，作为初始化。</li> <li>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会 影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</li> <li>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的 值进行比较时会返回 true，使用三个等号时会返回 false。</li></ul> <blockquote><p>== 转化成同一类型后的值，看“值”是否相等。</p> <p>=== 不转化，比较类型和值。</p></blockquote> <h2 id="判断数据类型的四种方式"><a href="#判断数据类型的四种方式" class="header-anchor">#</a> 判断数据类型的四种方式</h2> <ol><li>typeof判断基本类型，Array、Object、Null都是'object', 其余都返回自己的类型；</li> <li>instance of判断引用数据类型，内部运行机制是判断在其原型链中能否找到该类型的原型；</li> <li>constructor判断数据类型，对象实例通过constructor对象访问它的构造函数；((2).constructor === Number); // true)；</li> <li>Object.prototype.toString.call()，最准确。</li></ol> <h2 id="object-is-与比较操作符-、-的区别"><a href="#object-is-与比较操作符-、-的区别" class="header-anchor">#</a> Object.is() 与比较操作符 “===”、“==” 的区别</h2> <p>使用双等号(==)进行相等判断时，如果两边的类型不一致，则会进 行强制类型转化后再进行比较。</p> <p>使用三等号(===)进行相等判断时，如果两边的类型不一致时，不 会做强制类型准换，直接返回 false。</p> <p>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相 同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p> <h2 id="escape、encodeuri、encodeuricomponent-的区别"><a href="#escape、encodeuri、encodeuricomponent-的区别" class="header-anchor">#</a> escape、encodeURI、encodeURIComponent 的区别</h2> <p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合 法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p> <p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊 字符也会得到转义。</p> <p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式， 再在每个字节前加上 %。</p> <h2 id="什么是尾调用-使用尾调用有什么好处"><a href="#什么是尾调用-使用尾调用有什么好处" class="header-anchor">#</a> 什么是尾调用，使用尾调用有什么好处?</h2> <p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行 栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上 下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话， 因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上 下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优 化只在严格模式下开启，正常模式是无效的。</p> <h2 id="js判断空对象"><a href="#js判断空对象" class="header-anchor">#</a> JS判断空对象</h2> <ol><li>JSON.stringify()</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let obj = {}
console.log(JSON.stringify(obj) === '{}') // true
</code></pre></div><ol start="2"><li>for in</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let obj = {}
let result = function(obj) {
    for(let key in obj) { // 若不为空，可遍历，返回false；为空不进入循环，返回true
        console.log('key', key)
        return false
    }
    return true
}
console.log(result(obj)) // true
</code></pre></div><ol start="3"><li>Object.keys(): 返回对象属性名组成的数组，如果长度为0，则为空对象（ES6）</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let obj = {}
console.log(Object.keys(obj).length === 0) // true
</code></pre></div><ol start="4"><li>Object.getOwnPropertyNames(): 获取对象的属性名，存放到数组中，如果长度为0，则为空对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let obj = {}
console.log(Object.getOwnPropertyNames(obj).length === 0) // true
</code></pre></div><ol start="5"><li>jQuery中的isEmptyObject(): 原理是利用for in的方式来判断（记得引入jquery）</li></ol> <div class="language- extra-class"><pre class="language-text"><code>console.log($.isEmptyObject(obj)); // true
</code></pre></div><h2 id="代码检查工具-husky-eslint-prettier-lint-staged"><a href="#代码检查工具-husky-eslint-prettier-lint-staged" class="header-anchor">#</a> 代码检查工具 husky eslint prettier lint-staged</h2> <p><strong>eslint</strong>：代码规范检查工具，可以对代码进行约束规范。</p> <ul><li>写法：跟目录创建.eslintrc文件，还可自动修复报错（--fix）。</li></ul> <p><strong>prettier</strong>：代码格式化工具（检查和自动修复）代码保存自动格式化。</p> <ul><li>在commit前让pre-commit执行prettier来检查代码是否合格</li> <li>写法：根目录新建 .prettierrc 配置文件。</li></ul> <p><strong>lint-staged</strong>:  比如 eslint 命令需要指定 src/*.js ，但这样会产生新的问题，如果 src 目录存在着大量的 .js 文件，那么每次执行 eslint 时都会对所有文件检查&amp;修复，很明显除了对性能有影响外，还会影响同事以前写过的代码格式。</p> <ul><li>lint-staged可以只检查&amp;修复我们修改过的文件，能让这些插件只扫描暂存区的文件而不是全盘扫描。</li> <li>写法：在 package.json 新增 lint-staged 选项</li></ul> <div class="language- extra-class"><pre class="language-text"><code>lint-staged: {&quot;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}&quot;: [
    &quot;eslint --fix&quot;
]}
</code></pre></div><p><strong>husky</strong>: 在使用git commit时对代码进行eslint检查，git本身的一些勾子如pre-commit使用起来稍微麻烦，husky容易.</p> <ul><li>npm安装完跟目录会有.husky目录pre-commit配置文件，可自定义命令。</li></ul> <h2 id="es6-map-和-weakmap-的区别"><a href="#es6-map-和-weakmap-的区别" class="header-anchor">#</a> es6 Map()和 WeakMap()的区别</h2> <p>都是一组键值对的集合。都是构造函数，使用new创建。</p> <p>**Map: **ES6提供的数据结构，因为传统的对象只能用字符串当作键，给使用带来很大的不便，所以产生了Map。</p> <p>Map类似于对象，也是键值对的集合。但是键的范围不限于字符串，可以是各种类型的值，包括对象。</p> <p><strong>MeakMap</strong>：WeakMap设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收，当对象被回收后，自动移除对应的键值对.</p> <ul><li>典型应用是，一个对应dom元素的WeakMap结构，当某个dom元素被删除后，其对应的WeakMap记录会被自动清除。</li> <li>专用场合是，他的键所对应的对象，可能会在将来消失，因此，MeakMap有助于防止内存泄漏。</li></ul> <ol><li>WeakMap的键必须是对象，值可以是任意的；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var weakMap = new WeakMap()
weakMap.set({}, 'XD')
</code></pre></div><ol start="2"><li>WeakMap中的对象都是弱引用，即垃圾回收机制不考虑WeakMap对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么回收机制会自动回收该对象所占的内存，不考虑该对象还存在于WeakMap中。</li></ol> <p>WeakMap 只有四个常用方法：</p> <ul><li>通过键检查元素是否存在 has(key)</li> <li>添加元素 set(key , value)</li> <li>通过键移除元素 delete(key)</li> <li>通过键获取值 get(key)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var meakMap = new WeakMap()
var obj1 = {}, obj2 = {}
meakMap.set(obj1, 'obj1')
meakMap.set(obj2, 'obj2')

meakMap.has(obj1) // true
meakMap.get(obj2) // 'obj2
meakMap.delete(obj1) // true
meakMap.has(obj1) // false
</code></pre></div><p><strong>区别：</strong></p> <ol><li>WeakMap的键必须是对象，键名所指向的对象，不计入垃圾回收机制；Map的键可以是任意值；</li> <li>WeakMap没有size属性，没有遍历操作；</li> <li>WeakMap没有key()、value()、entries()，而且无法清空（不支持clear方法）</li></ol> <h2 id="setinterval和settimeout的区别"><a href="#setinterval和settimeout的区别" class="header-anchor">#</a> setInterval和setTimeout的区别</h2> <p>定时器，可以规定延迟时间再执行某个操作。</p> <ul><li>setInterval：可以一直循环下去，使用window.clearInterval()清除。</li> <li>setTimeout在规定时间后执行完某个操作就停止了。</li></ul> <p>使用函数名作为调用句柄的时候不能带参数，使用字符串调用可以。setTimeout(fun, 1000)或setTimeout('fun(name)', 1000)</p> <h2 id="test和includes哪个性高更高"><a href="#test和includes哪个性高更高" class="header-anchor">#</a> test和includes哪个性高更高？</h2> <p>在 JavaScript 中，test() 方法和 includes() 方法都是用于字符串的匹配操作。它们的区别如下：</p> <p>test() 方法是 RegExp 对象的方法，用于检测字符串是否与指定的正则表达式匹配。返回值为 true 或 false。</p> <p>includes() 方法是字符串对象的方法，用于检测一个字符串中是否包含另一个字符串。返回值为 true 或 false。</p> <p>在性能方面，<strong>includes() 方法的性能更高</strong>，因为它是字符串对象的本地方法，执行效率更快；而 test() 方法需要先将正则表达式编译成 RegExp 对象，再进行匹配，相对较慢。但是，在进行匹配时，如果需要使用复杂的正则表达式，test() 方法可能会更加灵活和可控。</p> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">7/10/2023, 8:34:02 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/src/面试题/HTML.html" class="prev">
        HTML
      </a></span> <span class="next"><a href="/blog/src/面试题/Node.html">
        Node
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.56ce6fa7.js" defer></script><script src="/blog/assets/js/2.9c076bee.js" defer></script><script src="/blog/assets/js/75.18fe6eaa.js" defer></script><script src="/blog/assets/js/19.aff3d43c.js" defer></script>
  </body>
</html>
