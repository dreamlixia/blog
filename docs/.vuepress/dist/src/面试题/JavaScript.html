<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lynsey&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="This is a blog.">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b6bfb1ac.css" as="style"><link rel="preload" href="/blog/assets/js/app.5fd0b9b2.js" as="script"><link rel="preload" href="/blog/assets/js/2.53652cad.js" as="script"><link rel="preload" href="/blog/assets/js/74.64001603.js" as="script"><link rel="preload" href="/blog/assets/js/18.23c9d995.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.33b1c0ff.js"><link rel="prefetch" href="/blog/assets/js/11.ccdbbfab.js"><link rel="prefetch" href="/blog/assets/js/12.8796df02.js"><link rel="prefetch" href="/blog/assets/js/13.8087dbc3.js"><link rel="prefetch" href="/blog/assets/js/14.fbc18135.js"><link rel="prefetch" href="/blog/assets/js/15.5d87d91f.js"><link rel="prefetch" href="/blog/assets/js/16.a91e1759.js"><link rel="prefetch" href="/blog/assets/js/17.a75234a7.js"><link rel="prefetch" href="/blog/assets/js/19.7685c0e0.js"><link rel="prefetch" href="/blog/assets/js/20.8add78e0.js"><link rel="prefetch" href="/blog/assets/js/21.f5083332.js"><link rel="prefetch" href="/blog/assets/js/22.eae1e092.js"><link rel="prefetch" href="/blog/assets/js/23.f243c3e2.js"><link rel="prefetch" href="/blog/assets/js/24.1ffa565b.js"><link rel="prefetch" href="/blog/assets/js/25.67520366.js"><link rel="prefetch" href="/blog/assets/js/26.bca90f25.js"><link rel="prefetch" href="/blog/assets/js/27.a454189f.js"><link rel="prefetch" href="/blog/assets/js/28.8f894708.js"><link rel="prefetch" href="/blog/assets/js/29.0a4bd2a9.js"><link rel="prefetch" href="/blog/assets/js/3.b344ead8.js"><link rel="prefetch" href="/blog/assets/js/30.d3367ce5.js"><link rel="prefetch" href="/blog/assets/js/31.0b56ecae.js"><link rel="prefetch" href="/blog/assets/js/32.d69c1d59.js"><link rel="prefetch" href="/blog/assets/js/33.95d909c9.js"><link rel="prefetch" href="/blog/assets/js/34.23c3ced2.js"><link rel="prefetch" href="/blog/assets/js/35.22134fb5.js"><link rel="prefetch" href="/blog/assets/js/36.30656c24.js"><link rel="prefetch" href="/blog/assets/js/37.adc51534.js"><link rel="prefetch" href="/blog/assets/js/38.9a29b4f5.js"><link rel="prefetch" href="/blog/assets/js/39.996aa388.js"><link rel="prefetch" href="/blog/assets/js/4.1afb75fb.js"><link rel="prefetch" href="/blog/assets/js/40.bbea6d3c.js"><link rel="prefetch" href="/blog/assets/js/41.5ee4393a.js"><link rel="prefetch" href="/blog/assets/js/42.53fa9e1b.js"><link rel="prefetch" href="/blog/assets/js/43.aabd0364.js"><link rel="prefetch" href="/blog/assets/js/44.74a41bb2.js"><link rel="prefetch" href="/blog/assets/js/45.7ca2b0dc.js"><link rel="prefetch" href="/blog/assets/js/46.7665e355.js"><link rel="prefetch" href="/blog/assets/js/47.686bdc8a.js"><link rel="prefetch" href="/blog/assets/js/48.4e37c758.js"><link rel="prefetch" href="/blog/assets/js/49.71ad7ac3.js"><link rel="prefetch" href="/blog/assets/js/5.58e9c542.js"><link rel="prefetch" href="/blog/assets/js/50.c564eae5.js"><link rel="prefetch" href="/blog/assets/js/51.1216f170.js"><link rel="prefetch" href="/blog/assets/js/52.9543da59.js"><link rel="prefetch" href="/blog/assets/js/53.9864ad0e.js"><link rel="prefetch" href="/blog/assets/js/54.801e12f8.js"><link rel="prefetch" href="/blog/assets/js/55.d6692eb8.js"><link rel="prefetch" href="/blog/assets/js/56.eb3e8c79.js"><link rel="prefetch" href="/blog/assets/js/57.fa0575e7.js"><link rel="prefetch" href="/blog/assets/js/58.48e7f887.js"><link rel="prefetch" href="/blog/assets/js/59.e997c7d5.js"><link rel="prefetch" href="/blog/assets/js/6.bfe89abf.js"><link rel="prefetch" href="/blog/assets/js/60.d8430135.js"><link rel="prefetch" href="/blog/assets/js/61.eed30a24.js"><link rel="prefetch" href="/blog/assets/js/62.d904e814.js"><link rel="prefetch" href="/blog/assets/js/63.877bbc5d.js"><link rel="prefetch" href="/blog/assets/js/64.3a8e6f31.js"><link rel="prefetch" href="/blog/assets/js/65.3e39b16a.js"><link rel="prefetch" href="/blog/assets/js/66.bd409698.js"><link rel="prefetch" href="/blog/assets/js/67.7faadc2d.js"><link rel="prefetch" href="/blog/assets/js/68.0707631d.js"><link rel="prefetch" href="/blog/assets/js/69.a337537c.js"><link rel="prefetch" href="/blog/assets/js/7.cd989559.js"><link rel="prefetch" href="/blog/assets/js/70.6e958bf5.js"><link rel="prefetch" href="/blog/assets/js/71.bf1d1cf4.js"><link rel="prefetch" href="/blog/assets/js/72.5799f318.js"><link rel="prefetch" href="/blog/assets/js/73.ff76f2e0.js"><link rel="prefetch" href="/blog/assets/js/75.d1c7dc39.js"><link rel="prefetch" href="/blog/assets/js/76.920afe2c.js"><link rel="prefetch" href="/blog/assets/js/77.2292f371.js"><link rel="prefetch" href="/blog/assets/js/8.1f2876e9.js"><link rel="prefetch" href="/blog/assets/js/9.eb56a451.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b6bfb1ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="https://github.com/dreamlixia/blog/raw/master/images/title.jpeg" alt="Lynsey's blog" class="logo"> <span class="site-name can-hide">Lynsey's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/src/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/src/面试题/HTML/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/blog/src/手写题/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/blog/src/算法题/JS/" class="nav-link">
  算法题
</a></div><div class="nav-item"><a href="/blog/src/操作手册/开发运行此项目/" class="nav-link">
  操作手册
</a></div><div class="nav-item"><a href="/blog/src/主页/" class="nav-link">
  主页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/src/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/src/面试题/HTML/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/blog/src/手写题/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/blog/src/算法题/JS/" class="nav-link">
  算法题
</a></div><div class="nav-item"><a href="/blog/src/操作手册/开发运行此项目/" class="nav-link">
  操作手册
</a></div><div class="nav-item"><a href="/blog/src/主页/" class="nav-link">
  主页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/src/面试题/CSS.html" class="sidebar-link">CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/CSS.html#css" class="sidebar-link">------ CSS ------</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/CSS.html#css引入的方式有哪些-link和-import的区别是什么" class="sidebar-link">CSS引入的方式有哪些，link和@import的区别是什么</a></li></ul></li><li><a href="/blog/src/面试题/HTML.html" class="sidebar-link">HTML</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html" class="sidebar-link">------ HTML ------</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html语义化的理解" class="sidebar-link">html语义化的理解</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#iframe-标签有哪些缺点-为什么要尽量少用-iframe-标签" class="sidebar-link">&lt;iframe\&gt;标签有哪些缺点？为什么要尽量少用&lt;iframe\&gt;标签</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#label的作用是什么-怎么用的" class="sidebar-link">Label的作用是什么？怎么用的</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#meta-标签的viewport的作用和原理是什么" class="sidebar-link">&lt;meta\&gt;标签的viewport的作用和原理是什么</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html5的新特性" class="sidebar-link">html5的新特性</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#本地存储cookie、localstorage、sessionstorage的区别及优缺点" class="sidebar-link">本地存储cookie、localStorage、sessionStorage的区别及优缺点</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#前端页面分为哪三层" class="sidebar-link">前端页面分为哪三层</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#前端需要注意哪些seo" class="sidebar-link">前端需要注意哪些SEO</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#介绍下你对浏览器内核的理解" class="sidebar-link">介绍下你对浏览器内核的理解</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html标签中的src和href有什么区别" class="sidebar-link">html标签中的src和href有什么区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/HTML.html#html渲染页面的过程" class="sidebar-link">html渲染页面的过程</a></li></ul></li><li><a href="/blog/src/面试题/JavaScript.html" class="active sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#javascript" class="sidebar-link">------ JavaScript ------</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#异步加载的几种方式" class="sidebar-link">异步加载的几种方式</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#防抖-debounce" class="sidebar-link">防抖（debounce）</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#节流-throttle" class="sidebar-link">节流（throttle）</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#介绍下promise和all方法" class="sidebar-link">介绍下Promise和all方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#promise和async-await的区别" class="sidebar-link">promise和async await的区别</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#数组的常用方法" class="sidebar-link">数组的常用方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#reduce这个方法通常用于什么场景" class="sidebar-link">reduce这个方法通常用于什么场景？</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#字符串的常用方法" class="sidebar-link">字符串的常用方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#对象的常用方法" class="sidebar-link">对象的常用方法</a></li><li class="sidebar-sub-header"><a href="/blog/src/面试题/JavaScript.html#new和object-create-的区别" class="sidebar-link">new和Object.create()的区别</a></li></ul></li><li><a href="/blog/src/%E9%9D%A2%E8%AF%95%E9%A2%98/" aria-current="page" class="sidebar-link">面试题</a></li><li><a href="/blog/src/面试题/hash路由和history路由.html" class="sidebar-link">hash路由和history路由</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/src/面试题/solid五大设计原则.html" class="sidebar-link">solid五大设计原则</a><ul class="sidebar-sub-headers"></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="javascript"><a href="#javascript" class="header-anchor">#</a> ------ JavaScript ------</h2> <h2 id="异步加载的几种方式"><a href="#异步加载的几种方式" class="header-anchor">#</a> 异步加载的几种方式</h2> <ol><li>defer: script被异步加载后并不会立即执行，而是等待文档被解析后执行。
<ul><li>只适用于外联脚本，如果script没有制定src属性，只是内联脚本，不要使用defer；</li> <li>如果有多个声明了defer的sript，则会按顺序下载和执行；</li> <li>defer脚本会在DOMContentLoader和load事件之前执行</li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;&gt;defer&lt;/script&gt;
</code></pre></div><ol start="2"><li>async: html5为script元素定义的属性，只能异步加载外部的链接文件，不能加载内部脚本
<ul><li>在js文件加载完后立即执行；</li> <li>如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序；</li> <li>async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序</li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;
</code></pre></div><ol start="3"><li>动态创建script标签，按需加载，节省资源，在需要用到的时候再去引入。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function loadScript(url, callback) {
    var script = document.createElement('script');
    if(script.readyState) {
        script.onreadystatechange = function() {
            if(script.readyState == 'loaded' || script.readyState == 'complate') {
                callback();
            }
        }
    } else {
        script.onload = function() {
            callback();
        }
    }
    script.url = url;
    document.body.appendChild(script);
}
</code></pre></div><h2 id="防抖-debounce"><a href="#防抖-debounce" class="header-anchor">#</a> 防抖（debounce）</h2> <p>不管事件的触发频率多高，一定在事件触发的 n 秒后才执行，如果你在事件触发后 n 秒内又触发了这个事件，那么以新的时间为准，n 秒后再执行。</p> <div class="language- extra-class"><pre class="language-text"><code>function debounce(event, time) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            event.apply(this, args);
        }, time);
    }
}
</code></pre></div><p>有时候我们需要立即执行一次函数，再等后面事件触发后等待 n 秒执行，我们给 debounce 函数一个 flag 标示。</p> <div class="language- extra-class"><pre class="language-text"><code>function debounce(event, time) {
    let timer = null;
    let flag = true;
    return function(...args) {
        clearTimeout(timer);
        if(flag &amp;&amp; !timer) {
            event.apply(this, args);
            flag = false;
        }
        timer = setTimeout(() =&gt; {
            event.apply(this, args);
        }, time);
    }
}
</code></pre></div><h2 id="节流-throttle"><a href="#节流-throttle" class="header-anchor">#</a> 节流（throttle）</h2> <p>不管事件的触发频率有多高，只在单位时间内执行一次。</p> <p><span style="text-decoration:underline;color:blue;">时间戳</span>和定时器结合，第一次和最后一次都会触发的版本。</p> <div class="language- extra-class"><pre class="language-text"><code>function throttle(event, time) {
    let pre = 0; // 记录上次的时间
    let timer = null;
    return function(...args) {
        if(Date.now() - pre &gt; time) { // 当前时间-上次时间 &gt; 等待时间
            clearTimeout(timer);
            pre = Date.now(); // 重置上次的时间
            event.apply(this, args); // 执行函数
        } else if(!timer) {
            timer = setTimeout(() =&gt; {
                event.apply(this, args);
            }, time);
        }
    }
}
</code></pre></div><h2 id="介绍下promise和all方法"><a href="#介绍下promise和all方法" class="header-anchor">#</a> 介绍下Promise和all方法</h2> <p>Promise是异步编程的一种解决方案。有以下两个特点，对象的状态不受外界影响和一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。Promise对象是一个构造函数，用来生成promise实例，接受一个函数作为参数，该函数的两个参数分别是resolve和reject。promise的方法有then、catch、finally、resolve、reject等。</p> <p>Promise.all()方法可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功时返回一个数组，失败的时候则返回最先被reject失败状态的值。</p> <p>需要特别注意的是， Promise.all获得的成功结果的数据里面的数据顺序和Promise.all接收到的数组顺序是一致的，即使前面的结果后返回，得到的数组顺序也是在前的。适用场景：前端开发请求数据的过程中，发送多个请求并根据请求顺序获取和使用数据。</p> <h2 id="promise和async-await的区别"><a href="#promise和async-await的区别" class="header-anchor">#</a> promise和async await的区别</h2> <p>Promise的出现解决了传统callback函数导致的地域回调问题，但他的语法导致了它向纵向发展成了一个回调连，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使异步代码看起来像同步代码，await的本质是可以提供等同于“同步效果”的等待异步返回能力的语法糖，只有这一句执行完，才会执行下一句。</p> <p>async await与Promise一样，是非阻塞的。</p> <p>async await是基于Promise实现的，可以说是改良版的Promise，他不能用于普通的回调函数。</p> <h2 id="数组的常用方法"><a href="#数组的常用方法" class="header-anchor">#</a> 数组的常用方法</h2> <ol><li>push(): 后增一个或多个元素，返回新增后的数组长度，改变原数组；</li> <li>unshift()： 前增一个或多个元素，返回新增后的数组长度，改变原数组；</li> <li>pop()： 删除并返回数组的最后一个元素，返回删除的元素，若数组为空，返回undefined，改变原数组；</li> <li>shift()：删除并返回数组的第一个元素，返回删除的元素，若数组为空，返回undefined，改变原数组；</li> <li>slice()：按条件查找内容
<ul><li>slice(n, m): n其实下标，m结束下标，包含起始，不包含结束，截取出中间的内容，返回一个新数组，不改变原数组；</li> <li>slice(n): 从n截取到末尾；</li> <li>slice(0): 从头到尾截取，原样输出，可用于数组的克隆；</li> <li>slice(-n, -m): 支持负数，代表从末尾开始数第n位至第m位，截取中间的内容。</li></ul></li> <li>splice()：添加或删除数组中的元素
<ul><li>splice(n, howmany, arr1, arr2, ...): n起始下标，howmany删除长度，可以为0，代表不删除元素，arr1,arr2为新增的数组，改变原数组；</li></ul></li> <li>concat()： 拼接，合并两个或者多个数组，生成一个新的数组，不改变原数组；</li> <li>join()： 将数组的每一项用指定字符链接起来形成一个字符串，默认链接符卫','逗号；
<ul><li>join(): var arr = [1,2,3]; var str = arr.join(); // str = '1,2,3'</li> <li>join('-'): var arr = [1,2,3]; var str = arr.join('-'); // str = '1-2-3'</li></ul></li> <li>reverse(): 倒序数组，改变原数组；</li> <li>sort()： 排序，按照字符Unicode码进行排序，改变原数组；
<ul><li>从小到大排序： arr.sort((a, b) =&gt; a - b)</li> <li>从大到小排序： arr.sort((a, b) =&gt; b - a)</li> <li>按照数组对象中某个值进行排序：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var arr = [
    { name: '名字一', age: '13' },
    { name: '名字二', age: '12' },
    { name: '名字三', age: '10' },
]
function compare(param) {
    return function(a, b) {
        return a[param] - b[param]
    }
}
arr.sort(compare('age')) 
// arr = [
//    { name: '名字三', age: '10' }
//    { name: '名字二', age: '12' },
//    { name: '名字一', age: '13' },
// ]
</code></pre></div></li> <li>map()：原数组的每一项执行函数后，返回一个新的数组，有返回值，不改变原数组；</li> <li>forEach()： 没有返回值, 改变原数组；</li> <li>filter()： 过滤数组中符合条件的元素并返回一个新的数组；</li> <li>every(function)：对数组的每一项进行判断，如果每一项都符合则返回true，否则返回false；
<ul><li>从迭代开始，一旦有一个不符合条件，就返回false，不继续迭代下去</li></ul></li> <li>some(function)：对数组的任一项进行判断，如果有一项符合就返回true，都不符合则返回false；
<ul><li>一直在查找符合条件的值，一旦找到，则不继续迭代下去</li></ul></li> <li>reduce()： 接收一个函数作为累加器，最终计算为一个值；</li> <li>indexOf()：检测当前值在数组中第一次出现的位置索引，不改变原数组；
<ul><li>indexOf(item, start): item查找的元素，start从这个位置开始检索，找不到返回-1</li></ul></li> <li>includes()：判断一个数组是否包含一个指定的值，返回布尔值，不改变原数组；</li></ol> <h2 id="reduce这个方法通常用于什么场景"><a href="#reduce这个方法通常用于什么场景" class="header-anchor">#</a> reduce这个方法通常用于什么场景？</h2> <ol><li>计算数组元素之和或乘积；</li> <li>数组去重；</li> <li>计算数组中元素出现的次数；</li> <li>将二维或多维数组转化为一维数组；</li> <li>数组对象里的属性求和；</li></ol> <h2 id="字符串的常用方法"><a href="#字符串的常用方法" class="header-anchor">#</a> 字符串的常用方法</h2> <ol><li><p>charAt(index)：返回字符串中指定位置的字符；</p></li> <li><p>charCodeAt()：没有参数，str.charCodeAt(); 返回对应字符的ASCII码，如有多个值，则返回字符串中第一个值的ASCII码；</p></li> <li><p>fromCharCode(ASCII码)：String.fromCharCode(65); 填入ASCII码，就会得到对应的字符；</p></li> <li><p>includes(searchValue， start)：用于判断字符串是否包含指定字符，返回布尔值，searchValue必填，start选填，设置查找开始的位置，默认为0；</p></li> <li><p>concat()：拼接两个或多个字符串，不改变原字符串，返回拼接后的新字符串；</p></li> <li><p>split(separtator, limit)：用于把字符串分割成字符串数组，参数可以是符号也可以是字符串中的元素，两个参数都是可选的，separtator表示字符串或正则表达式，从该参数指定的地方分割，limit 指定返回的数组的最大长度；</p></li> <li><p>slice(start, end)：提取字符串的某个部分，包含起始位置，不包含结束位置，返回新的被提取部分的字符串；</p></li> <li><p>substr(start, howmany)：from开始裁切的下标，howmany要裁切的长度；</p></li> <li><p>substring(from, to)：from必须，to可选，不支持负数，提取两个指定字符之间的字符，to不填表示到结尾；</p></li> <li><p>indexOf(searchValue, start)：返回某个指定字符在字符串中首次出现的位置，没有匹配到返回-1， start选填；</p></li> <li><p>lastIndexOf()：同上，倒序查找；</p></li> <li><p>search()：检索字符串中的指定字符，或于正则表达式相匹配的字符串，返回起始位置下标；</p></li> <li><p>match()：可在字符串中根据正则找到一个或者多个匹配的值；</p></li> <li><p>trim()：去除收尾空格，没有参数；</p></li> <li><p>toLowerCase()：转化成小写；</p></li> <li><p>toUpperCase()：转化成大写；</p></li> <li><p>replace(searchValue, newValue)：用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子串；</p></li> <li><p>replaceAll()：该函数会替换掉所有匹配到的子字符串；</p></li> <li><p>repeat(n)：复制指定次数, var str = 'Hello'; var s = str.repeat(2); // s = 'HelloHello'</p></li></ol> <h2 id="对象的常用方法"><a href="#对象的常用方法" class="header-anchor">#</a> 对象的常用方法</h2> <ol><li>new：new对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 1.创建控对象后添加属性
const obj = {}
obj.uname = 'name'
obj.fn = () =&gt; {
    console.log('ggg')
}
console.log(obj)// { uname: 'name', fn: ƒ }
// 2. 创建对象并且直接添加属性(常用)
const obj1 = {
    uname: 'name',
    fn: () =&gt; {
        console.log('ggg')
    }
}
console.log(obj1) // { uname: 'name', fn: ƒ }
</code></pre></div><ol start="2"><li>Object.create(Person.prototype, {})：创建一个新对象，使用第一个参数来提供新创建对象的_proto__(以第一个参数作为对象的构造函数的原型对象)，第二个参数为可选参数，添加到新创建的对象中的属性；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const a = Object.create(Person.prototype, {
    age: {
        value: 12,
        writable: true,
        configurable: true
    }
})
</code></pre></div><h2 id="new和object-create-的区别"><a href="#new和object-create-的区别" class="header-anchor">#</a> new和Object.create()的区别</h2> <p>new产生的对象，优化获取构造函数上的属性，找不到才回去原型上找；</p> <p>如果构造函数中以及原型上都没有对应的属性，就会报错；</p> <p>Object.create() 产生的对象，只会在原型上进行查找属性，原型上没有对应的属性，就会报错；</p> <ol start="3"><li><p>delete：删除属性，const o = { p: 10, m: 20 }; delete o.p; console.log(o); // { m: 20 }</p></li> <li><p>Object.assign(target, ...sources)：将所有可枚举的自身属性从一个或多个源对象复制到目标对象，返回修改后的对象；</p></li> <li><p>Object.getOwnPropertyNames()：返回自有属性的名称（不管是不是可枚举的）</p></li> <li><p>for in：遍历对象中所有的可枚举属性（包括自身属性和继承属性）</p></li> <li><p>Object.keys(obj)：返回给定对象自己的可枚举属性名称的数组；</p></li> <li><p>Object.values(obj)：返回给定对象自己的可枚举属性值的数组；</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>const object2 = {
    a: 'a',
    b: 'b',
    c: 'c'
}
Object.values(object2); // ['a', 'b', 'c'] // 按顺序
</code></pre></div><ol start="9"><li>Object.entries(obj)：返回给定对象自己的可枚举属性[key, value]的数组</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const object1 = { name: 'David', age: 23 }
Object.entries(object1) // [['name', 'David'], ['age', 23]]
</code></pre></div><ol start="10"><li>Object.fromEntries(iterable)：参数iterable类似Array、Map或者其他实现了可迭代协议的可迭代对象，返回一个由该迭代对象条目提供对应属性的新对象。该方法把键值对列表转换为一个对象，与Object.entries()相反。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const entries = new Map([
    [ 'name', '姓名' ],
    [ 'age',  13 ]
])
const obj = Object.fromEntries(entries); // { name: '姓名', age: 13 } 
</code></pre></div><ol start="11"><li>Object.prototype.hasOwnProperty(prop)：返回一个布尔值，指示对象是否具有指定的属性作为他自己的属性，如果是对象的直接属性，则返回true，即使值为null或未定义；如果该属性是继承的或根本没有声明，则返回false；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const object3 = {}
object3.prototype1 = 1
Object.prototype.hasOwnProperty('prototype1'); // true
Object.prototype.hasOwnProperty('toString'); // false
</code></pre></div><ol start="12"><li><p>Object.prototype.toString()：返回一个表示对象的字符串。</p></li> <li><p>Object.is(val1, val2)：判读两个值是否相同，返回布尔值；</p></li></ol> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">2/22/2023, 9:55:39 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/src/面试题/HTML.html" class="prev">
        HTML
      </a></span> <span class="next"><a href="/blog/src/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="router-link-active">
        面试题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.5fd0b9b2.js" defer></script><script src="/blog/assets/js/2.53652cad.js" defer></script><script src="/blog/assets/js/74.64001603.js" defer></script><script src="/blog/assets/js/18.23c9d995.js" defer></script>
  </body>
</html>
