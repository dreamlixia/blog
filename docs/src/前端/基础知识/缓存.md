<!-- 缓存的主要手段有：浏览器缓存、CDN、反向代理、本地缓存、分布式缓存、数据库缓存。

前面三个缓存策略属于网站前端的范畴。 -->

1.缓存是什么
---
缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。

2.为什么要缓存（缓存的优点）
---
+ 缓解服务器压力，不用每次去请求资源
+ 提升性能，提高访问速度
+ 减少网络I/O消耗，减少带宽消耗
+ 如果是较大的响应需要在客户与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用

3.缓存类型
---
+ 总体可分为私有缓存（private）和共享缓存（public）
    - 私有缓存：该资源只能被浏览器缓存，private为默认值，只能用于单独用户
    - 共享缓存：该资源既可以被浏览器缓存，也可以被代理服务器缓存，能够被多个用户使用
+ 按种类分
    - 数据库缓存
    - 代理服务器缓存
    - 网关缓存（CDN）
    - 浏览器缓存

4.浏览器缓存机制
---
+ 浏览器缓存位置分析
+ HTTP缓存策略
+ 用户行为对缓存的影响

4.1 浏览器缓存位置分析
---
从缓存位置上来说分为四种，并且各自有优先级，当一次查找缓存都没有命中的时候，才会去请求网络
+ Service Worker
    - 是一种独立于主线程之外的JavaScript线程。脱离于浏览器窗体，可以帮我们实现离线缓存、消息推送和网络代理等功能。
    - 使用Service Worker的话，传输协议必须使用HTTPS，来保障安全，因为涉及到请求拦截。
    - 缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、读取缓存，并且缓存是持续性的。
    - 使用了ES6中的Promise，并且在拦截请求的时候使用的是新的fetch API，因为fetch返回的是Promise对象。
    - Service Worker实现缓存分为三个步骤：注册Service Worker、监听到install事件以后就可以缓存需要的文件、下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在则先读取，否则请求数据。
+ Memory Cache(内存缓存)
    - 包括当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等
    - 因为存储在内存中，Memory Cache是响应速度最快的一种缓存，同时缓存持续性很短，会随着进程的释放而释放，tab关闭，缓存释放。
    - 不是所有资源都可以放进内存缓存中，计算机内存有限，比硬盘容量小很多。
    - 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头信息，小文件优先缓存在内存中。
+ Disk Cache(磁盘缓存)
    - Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
    - 会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。
        * 对于大文件来说，大概率是不存储在内存中的，反之优先
        * 当前系统内存使用率高的话，文件优先存储进硬盘
        * Base64 格式的图片，几乎永远可以被塞进 memory cache，加载时间为0，都是直接加载好的
        * 较大的样式文件和js文件都会进 Disk Cache，加载时间也相对较长
        > <font color="#3468ff">prefetch cache</font> 是一种浏览器预加载机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。
+ Push Cache(推送缓存)
    - Push Cache 是 HTTP2 在 server push 阶段存在的缓存，当以上三种缓存都没有命中时，它才会被使用。
    - Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
    - 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。
    - Push Cache 中的缓存只能被使用一次
    - 可以推送 no-cache 和 no-store 的资源
    - 浏览器可以拒绝接受已经存在的资源推送

4.2 HTTP缓存策略
---
当客户端向服务器请求资源时，会先抵达浏览器缓存，当以上缓存都没有命中的时候，我们就需要发起请求获取资源了。当然为了性能考虑，我们肯定不希望所有的资源每次都是请求来的。所以需要给不同的资源选择不同的缓存策略。

然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。

通常浏览器缓存策略分为三种：**强缓存，协商缓存和启发式缓存**，并且缓存策略都是通过设置 HTTP Header 来实现的。
- 强缓存
    + 不会向服务器发送请求，直接从缓存中读取资源。
    + 状态码：200，显示 from disk cache 或 from memory cache。
    + 设置两种 HTTP Header 实现：Expires（HTTP1.0 值是时间戳） 和 Cache-Control（HTTP1.1）。
- 协商缓存：当 Cache-Control 和 Expires 过期或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。
    + 如果服务器端的资源没有修改（Not Modified），那么就会返回304状态码，告诉浏览器可以使用缓存中的数据。
- 启发式缓存：如果Expires，Cache-Control: max-age，或 Cache-Control:s-maxage都没有在响应头中出现，并且设置了Last-Modified时，那么浏览器默认会采用一个启发式的算法，即启发式缓存：根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。这是浏览器默认的缓存方式

**频繁变动的资源，使用协商缓存**
```
Cache-Control: no-cache
```

**不常变化的资源，静态资源，使用强缓存并配合文件名添加hash**
```
Cache-Control: max-age=31536000
```