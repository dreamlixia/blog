异步加载的几种方式
---
1. defer: script被异步加载后并不会立即执行，而是等待文档被解析后执行。
    - 只适用于外联脚本，如果script没有制定src属性，只是内联脚本，不要使用defer；
    - 如果有多个声明了defer的sript，则会按顺序下载和执行；
    - defer脚本会在DOMContentLoader和load事件之前执行
```
<script defer src=""></script>
<script src="">defer</script>
```
2. async: html5为script元素定义的属性，只能异步加载外部的链接文件，不能加载内部脚本
    - 在js文件加载完后立即执行；
    - 如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序；
    - async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序
```
<script src="" async></script>
```
3. 动态创建script标签，按需加载，节省资源，在需要用到的时候再去引入。
```
function loadScript(url, callback) {
    var script = document.createElement('script');
    if(script.readyState) {
        script.onreadystatechange = function() {
            if(script.readyState == 'loaded' || script.readyState == 'complate') {
                callback();
            }
        }
    } else {
        script.onload = function() {
            callback();
        }
    }
    script.url = url;
    document.body.appendChild(script);
}
```

防抖（debounce）
---
不管事件的触发频率多高，一定在事件触发的 n 秒后才执行，如果你在事件触发后 n 秒内又触发了这个事件，那么以新的时间为准，n 秒后再执行。
```
function debounce(event, time) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            event.apply(this, args);
        }, time);
    }
}
```
有时候我们需要立即执行一次函数，再等后面事件触发后等待 n 秒执行，我们给 debounce 函数一个 flag 标示。
```
function debounce(event, time, flag) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        if(flag && !timer) {
            event.apply(this, args);
        }
        timer = setTimeout(() => {
            event.apply(this, args);
        }, time);
    }
}
```

节流（throttle）
---
不管事件的触发频率有多高，只在单位时间内执行一次。

时间戳和定时器结合，第一次和最后一次都会触发的版本。
```
function throttle(event, time) {
    let pre = 0; 
    let timer = null;
    return function(...args) {
        if(Date.now() - pre > time) {
            clearTimeout(timer);
            timer = null;
            pre = Date.now();
            event.apply(this, args);
        } else if(!timer) {
            timer = setTimeout(() => {
                event.apply(this, args);
            }, time);
        }
    }
}
```