### 如何保存页面当前的状态
---

两种情况：组件会被卸载或不会被卸载

#### 组件会被卸载：
1. 使用LocalStorage / SessionStorage

    在组件即将销毁的生命周期（componentWillUnmount / beforeDestroy）使用此方法，需要注意的是组件更新状态的时机。

    **优点：**
    - 兼容性好，不需要引入第三方库或者工具；
    - 简单快捷，可以满足大部分需求；

    **缺点：**
    - 状态通过JSON存储（相当于深拷贝），如果状态中有特殊情况（Date对象/Regexp对象）会得到字符串而不是原来的值；
    - 使用标示flag时，执行后退、下一页等操作会失效；
2. 路由传参

    使用react-router的link，prop -- to 实现路由传递参数，通过history.location.state获取

    **优点：**
    - 简单快捷，不会污染LocalStorage/SessionStorage;
    - 可以存储Date对象和Regexp对象；（不用担心JSON.stringify()和parse()的不足）
    
    **缺点：**
    - 如果跳转页面过多，每个页面都需要使用同样的方法进行传值取值，相当冗余混乱；

#### 组件不会被卸载：
1. 单页面页面渲染

    父子组件正常传参（prop）的方式

    **优点：**
    - 代码量少，方便

    **缺点：**
    - 无法用路由定位页面

2. keep-alive

   \<keep-alive\> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。是一个抽象组件，它自身不会渲染一个组件，也不会出现在组件的父组件链中。

    主要用于保存组件状态或避免重新渲染。
    ```
    <keep-alive>
        <component :is="view"></component>
    </keep-alive>
    ```

    ```
    <keep-alive>
        <component v-if="$router.meta.keepAlive"></component>
    </keep-alive>

    // router.js
    {
        path: '/',
        name: '',
        component: () => import('./../src/XXX.vue'),
        meta: {
            keepAlive: true // 需要被缓存
        }
    }
    ```